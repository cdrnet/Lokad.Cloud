<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Lokad.Shared</name>
  </assembly>
  <members>
    <member name="T:GlobalAssemblyInfo">
      <summary>
             Assembly information class that is shared between all projects
            </summary>
    </member>
    <member name="T:Lokad.ActionExtensions">
      <summary>
            Extensions for the <see cref="T:System.Action" /></summary>
    </member>
    <member name="M:Lokad.ActionExtensions.AsDisposable(System.Action)">
      <summary>
            Converts the action into <see cref="T:Lokad.DisposableAction" /></summary>
      <param name="action">The action.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Lokad.ArrayExtensions">
      <summary>
            Shortcuts for some common array operations
            </summary>
    </member>
    <member name="M:Lokad.ArrayExtensions.Convert``2(``0[],System.Converter{``0,``1})">
      <summary>
            Shorthand extension method for converting the arrays
            </summary>
      <typeparam name="TSource">The type of the source array.</typeparam>
      <typeparam name="TTarget">The type of the target array.</typeparam>
      <param name="source">The array to convert.</param>
      <param name="converter">The converter.</param>
      <returns>target array instance</returns>
    </member>
    <member name="M:Lokad.ArrayExtensions.Convert``2(``0[],System.Func{``0,System.Int32,``1})">
      <summary>
            Shorthand extension method for converting the arrays
            </summary>
      <typeparam name="TSource">The type of the source array.</typeparam>
      <typeparam name="TTarget">The type of the target array.</typeparam>
      <param name="source">The array to convert.</param>
      <param name="converter">The converter, where the second parameter is an index of item being converted.</param>
      <returns>target array instance</returns>
    </member>
    <member name="M:Lokad.ArrayExtensions.ForEach``1(``0[],System.Action{``0})">
      <summary>
            Applies the action to each item in the array
            </summary>
      <typeparam name="T">type of the items in the array</typeparam>
      <param name="self">The array to walk through.</param>
      <param name="action">The action.</param>
      <returns>Same array instance</returns>
    </member>
    <member name="M:Lokad.ArrayExtensions.SliceArray``1(``0[],System.Int32)">
      <summary>
            Slices array into array of arrays of length up to <paramref name="sliceLength" /></summary>
      <typeparam name="T">Type of the items int the array</typeparam>
      <param name="array">The array.</param>
      <param name="sliceLength">Length of the slice.</param>
      <returns>array of sliced arrays</returns>
      <exception cref="T:System.ArgumentNullException">When source array is null</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">When <paramref name="sliceLength" /> is invalid</exception>
    </member>
    <member name="T:Lokad.Diagnostics.ExceptionStatistics">
      <summary>
            Final statistics about the exceptions in some system
            </summary>
    </member>
    <member name="M:Lokad.Diagnostics.ExceptionStatistics.#ctor(System.Guid,System.Int64,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Diagnostics.ExceptionStatistics" /> class.
            </summary>
      <param name="id">The exception ID.</param>
      <param name="count">The exception count.</param>
      <param name="exception">The exception to associate with.</param>
    </member>
    <member name="M:Lokad.Diagnostics.ExceptionStatistics.#ctor(System.Guid,System.Int64,System.String,System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Diagnostics.ExceptionStatistics" /> class.
            </summary>
      <param name="id">Exception ID.</param>
      <param name="count">Exception count.</param>
      <param name="name">Exception name.</param>
      <param name="message">Exception message.</param>
      <param name="text">Exception text.</param>
    </member>
    <member name="P:Lokad.Diagnostics.ExceptionStatistics.ID">
      <summary>
            Gets the unique identifier of the exception
            </summary>
      <value>The ID.</value>
    </member>
    <member name="P:Lokad.Diagnostics.ExceptionStatistics.Count">
      <summary>
            Gets the number of times this exception did occur.
            </summary>
      <value>The number of times this exception did occur.</value>
    </member>
    <member name="P:Lokad.Diagnostics.ExceptionStatistics.Name">
      <summary>
            Gets the name of the exception.
            </summary>
      <value>The name.</value>
    </member>
    <member name="P:Lokad.Diagnostics.ExceptionStatistics.Message">
      <summary>
            Gets the message associated with the exception.
            </summary>
      <value>The message.</value>
    </member>
    <member name="P:Lokad.Diagnostics.ExceptionStatistics.Text">
      <summary>
            Gets the textual representation of the exception.
            </summary>
      <value>The text.</value>
    </member>
    <member name="T:Lokad.Testing.Equatable">
      <summary>
            Helper extensions for the <see cref="T:System.IEquatable`1" /> used in testing of models.
            </summary>
    </member>
    <member name="M:Lokad.Testing.Equatable.EqualsTo``1(System.IEquatable{``0},``0)">
      <summary>
            Checks if the specified object instance is equal to another instance
            </summary>
      <typeparam name="TObject">The type of the object.</typeparam>
      <param name="self">The object to check.</param>
      <param name="other">The other object to compare with.</param>
      <returns>
        <c>True</c> if the object instances are equal</returns>
    </member>
    <member name="M:Lokad.Testing.Equatable.EqualsTo``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``0})">
      <summary>
            Checks if the specified collection of object instances is equal to another similar collection
            </summary>
      <typeparam name="TObject">The type of the object.</typeparam>
      <param name="self">The collection to check.</param>
      <param name="other">The other collection.</param>
      <returns>
        <c>True</c> if all object instances are equal</returns>
    </member>
    <member name="T:System.Linq.ArrayExtensionsForLinq">
      <summary>
            Array extensions that belong to the LINQ namespace
            </summary>
    </member>
    <member name="M:System.Linq.ArrayExtensionsForLinq.Append``1(``0[],``0[])">
      <summary>
            Joins arrays together
            </summary>
      <typeparam name="T">type of the arrays</typeparam>
      <param name="self">The first array to join.</param>
      <param name="second">The second array to join.</param>
      <returns>Joined array</returns>
    </member>
    <member name="T:System.Linq.Indexer`1">
      <summary>
            Indexing wrapper that contains value and its integral position.
            </summary>
      <typeparam name="TSource">type of the underlying item</typeparam>
    </member>
    <member name="P:System.Linq.Indexer`1.Index">
      <summary>
            Gets the integral position of the item.
            </summary>
      <value>The integral position of the item.</value>
    </member>
    <member name="P:System.Linq.Indexer`1.IsFirst">
      <summary>
            Gets a value indicating whether this instance is first.
            </summary>
      <value>
        <c>true</c> if this instance is first; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:System.Linq.Indexer`1.Value">
      <summary>
            Gets the value.
            </summary>
      <value>The value.</value>
    </member>
    <member name="T:Lokad.Maybe`1">
      <summary>
            Helper class that indicates nullable value in a good-citizenship code
            </summary>
      <typeparam name="T">underlying type</typeparam>
    </member>
    <member name="F:Lokad.Maybe`1.Empty">
      <summary>
            Default empty instance.
            </summary>
    </member>
    <member name="M:Lokad.Maybe`1.Convert``1(System.Func{`0,``0})">
      <summary>
            Converts this instance to <see cref="T:Lokad.Maybe`1" />, 
            while applying <paramref name="converter" /> if there is a value.
            </summary>
      <typeparam name="TTarget">The type of the target.</typeparam>
      <param name="converter">The converter.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Lokad.Maybe`1.Apply(System.Action{`0})">
      <summary>
            Applies the specified action to the value, if it is present.
            </summary>
      <param name="action">The action.</param>
    </member>
    <member name="M:Lokad.Maybe`1.GetValue(System.Func{`0})">
      <summary>
            Retrieves value from this instance, using a 
            <paramref name="defaultValue" /> if it is absent.
            </summary>
      <param name="defaultValue">The default value.</param>
      <returns>value</returns>
    </member>
    <member name="M:Lokad.Maybe`1.GetValue(`0)">
      <summary>
            Retrieves value from this instance, using a 
            <paramref name="defaultValue" /> if it is absent.
            </summary>
      <param name="defaultValue">The default value.</param>
      <returns>value</returns>
    </member>
    <member name="M:Lokad.Maybe`1.Convert``1(System.Func{`0,``0},System.Func{``0})">
      <summary>
            Retrieves converted value, using a 
            <paramref name="defaultValue" /> if it is absent.
            </summary>
      <typeparam name="TTarget">type of the conversion target</typeparam>
      <param name="converter">The converter.</param>
      <param name="defaultValue">The default value.</param>
      <returns>value</returns>
    </member>
    <member name="M:Lokad.Maybe`1.Convert``1(System.Func{`0,``0},``0)">
      <summary>
            Retrieves converted value, using a 
            <paramref name="defaultValue" /> if it is absent.
            </summary>
      <typeparam name="TTarget">type of the conversion target</typeparam>
      <param name="converter">The converter.</param>
      <param name="defaultValue">The default value.</param>
      <returns>value</returns>
    </member>
    <member name="M:Lokad.Maybe`1.Equals(Lokad.Maybe{`0})">
      <summary>
            Determines whether the specified <see cref="T:Lokad.Maybe`1" /> is equal to the current <see cref="T:Lokad.Maybe`1" />.
            </summary>
      <param name="maybe">The <see cref="T:Lokad.Maybe" /> to compare with.</param>
      <returns>true if the objects are equal</returns>
    </member>
    <member name="M:Lokad.Maybe`1.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
      <exception cref="T:System.NullReferenceException">
            The <paramref name="obj" /> parameter is null.
            </exception>
    </member>
    <member name="M:Lokad.Maybe`1.GetHashCode">
      <summary>
            Serves as a hash function for this instance.
            </summary>
      <returns>
            A hash code for the current <see cref="T:Lokad.Maybe`1" />.
            </returns>
    </member>
    <member name="M:Lokad.Maybe`1.op_Equality(Lokad.Maybe{`0},Lokad.Maybe{`0})">
      <summary>
            Implements the operator ==.
            </summary>
      <param name="left">The left.</param>
      <param name="right">The right.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Lokad.Maybe`1.op_Inequality(Lokad.Maybe{`0},Lokad.Maybe{`0})">
      <summary>
            Implements the operator !=.
            </summary>
      <param name="left">The left.</param>
      <param name="right">The right.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Lokad.Maybe`1.op_Implicit(`0)~Lokad.Maybe{`0}">
      <summary>
            Performs an implicit conversion from <typeparamref name="T" /> to <see cref="T:Lokad.Maybe`1" />.
            </summary>
      <param name="item">The item.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Lokad.Maybe`1.op_Explicit(Lokad.Maybe{`0})~`0">
      <summary>
            Performs an explicit conversion from <see cref="T:Lokad.Maybe`1" /> to <typeparamref name="T" />.
            </summary>
      <param name="item">The item.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="P:Lokad.Maybe`1.Value">
      <summary>
            Gets the underlying value.
            </summary>
      <value>The value.</value>
    </member>
    <member name="P:Lokad.Maybe`1.HasValue">
      <summary>
            Gets a value indicating whether this instance has value.
            </summary>
      <value>
        <c>true</c> if this instance has value; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Lokad.Maybe">
      <summary>
            Helper routines for <see cref="T:Lokad.Maybe`1" /></summary>
    </member>
    <member name="M:Lokad.Maybe.From``1(``0)">
      <summary>
            Creates new <see cref="T:Lokad.Maybe`1" /> from the provided value
            </summary>
      <typeparam name="TSource">The type of the source.</typeparam>
      <param name="item">The item.</param>
      <returns>
        <see cref="T:Lokad.Maybe`1" /> that matches the provided value</returns>
      <exception cref="T:System.ArgumentNullException">if argument is a null reference</exception>
    </member>
    <member name="T:Lokad.Quality.ImmutableAttribute">
      <summary>
        <para>Class is considered to be immutable, when all fields are read-only.
            This makes the class safe for the multi-threaded operations.</para>
        <para>This attribute is used as a marker for code validation that actually enforced the rule</para>
      </summary>
    </member>
    <member name="T:Lokad.Quality.NoCodeCoverageAttribute">
      <summary>
            Attribute used to inform code coverage tool to ignore marked code block
            </summary>
    </member>
    <member name="P:Lokad.Quality.NoCodeCoverageAttribute.Justification">
      <summary> Gets or sets the justification for removing 
            the member from the unit test code coverage. </summary>
      <value>The justification.</value>
    </member>
    <member name="T:Lokad.Quality.AssertionConditionAttribute">
      <summary>
            Indicates the condition parameter of the assertion method. 
            The method itself should be marked by <see cref="T:Lokad.Quality.AssertionMethodAttribute" /> attribute.
            The mandatory argument of the attribute is the assertion type.
            </summary>
      <seealso cref="T:Lokad.Quality.AssertionConditionType" />
      <remarks>This attribute helps R# in code analysis</remarks>
    </member>
    <member name="M:Lokad.Quality.AssertionConditionAttribute.#ctor(Lokad.Quality.AssertionConditionType)">
      <summary>
            Initializes new instance of AssertionConditionAttribute
            </summary>
      <param name="conditionType">Specifies condition type</param>
    </member>
    <member name="P:Lokad.Quality.AssertionConditionAttribute.ConditionType">
      <summary>
            Gets condition type
            </summary>
    </member>
    <member name="T:Lokad.Quality.AssertionConditionType">
      <summary>
            Specifies assertion type. If the assertion method argument satisifes the condition, then the execution continues. 
            Otherwise, execution is assumed to be halted
            </summary>
    </member>
    <member name="F:Lokad.Quality.AssertionConditionType.IS_TRUE">
      <summary>
            Indicates that the marked parameter should be evaluated to true
            </summary>
    </member>
    <member name="F:Lokad.Quality.AssertionConditionType.IS_FALSE">
      <summary>
            Indicates that the marked parameter should be evaluated to false
            </summary>
    </member>
    <member name="F:Lokad.Quality.AssertionConditionType.IS_NULL">
      <summary>
            Indicates that the marked parameter should be evaluated to null value
            </summary>
    </member>
    <member name="F:Lokad.Quality.AssertionConditionType.IS_NOT_NULL">
      <summary>
            Indicates that the marked parameter should be evaluated to not null value
            </summary>
    </member>
    <member name="T:Lokad.Quality.AssertionMethodAttribute">
      <summary>
            Indicates that the marked method is assertion method, i.e. it halts control flow if one of the conditions is satisfied. 
            To set the condition, mark one of the parameters with <see cref="T:Lokad.Quality.AssertionConditionAttribute" /> attribute
            </summary>
      <seealso cref="T:Lokad.Quality.AssertionConditionAttribute" />
      <remarks>This attribute helps R# in code analysis</remarks>
    </member>
    <member name="T:Lokad.Quality.CanBeNullAttribute">
      <summary>
            Indicates that the value of marked element could be <c>null</c> sometimes, so the check for <c>null</c> is necessary before its usage
            </summary>
    </member>
    <member name="T:Lokad.Quality.CannotApplyEqualityOperatorAttribute">
      <summary>
            Indicates that the value of marked type (or its derivatives) cannot be compared using '==' or '!=' operators.
            There is only exception to compare with <c>null</c>, it is permitted
            </summary>
    </member>
    <member name="T:Lokad.Quality.ImplicitUseFlags">
      <summary>
            Used by <see cref="T:Lokad.Quality.MeansImplicitUseAttribute" /></summary>
    </member>
    <member name="F:Lokad.Quality.ImplicitUseFlags.STANDARD">
      <summary>
            Standard
            </summary>
    </member>
    <member name="F:Lokad.Quality.ImplicitUseFlags.ALL_MEMBERS_USED">
      <summary>
            All members used
            </summary>
    </member>
    <member name="T:Lokad.Quality.InvokerParameterNameAttribute">
      <summary>
            Indicates that the function argument should be string literal and match one  of the parameters of the caller function.
            For example, <see cref="T:System.ArgumentNullException" /> has such parameter.
            </summary>
      <remarks>This attribute helps R# in code analysis</remarks>
    </member>
    <member name="T:Lokad.Quality.MeansImplicitUseAttribute">
      <summary>
            Should be used on attributes and causes ReSharper to not mark symbols marked with such attributes as unused (as well as by other usage inspections)
            </summary>
      <remarks>This attribute helps R# in code analysis</remarks>
    </member>
    <member name="M:Lokad.Quality.MeansImplicitUseAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Quality.MeansImplicitUseAttribute" /> class with <see cref="F:Lokad.Quality.ImplicitUseFlags.STANDARD" />.
            </summary>
    </member>
    <member name="M:Lokad.Quality.MeansImplicitUseAttribute.#ctor(Lokad.Quality.ImplicitUseFlags)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Quality.MeansImplicitUseAttribute" /> class.
            </summary>
      <param name="flags">The flags.</param>
    </member>
    <member name="P:Lokad.Quality.MeansImplicitUseAttribute.Flags">
      <summary>
            Gets the flags.
            </summary>
      <value>The flags.</value>
    </member>
    <member name="T:Lokad.Quality.NotNullAttribute">
      <summary>
            Indicates that the value of marked element could never be <c>null</c></summary>
    </member>
    <member name="T:Lokad.Quality.StringFormatMethodAttribute">
      <summary>
            Indicates that marked method builds string by format pattern and (optional) arguments. 
            Parameter, which contains format string, should be given in constructor.
            The format string should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> -like form
            </summary>
      <remarks>
            This attribute helps R# in code analysis
            </remarks>
    </member>
    <member name="M:Lokad.Quality.StringFormatMethodAttribute.#ctor(System.String)">
      <summary>
            Initializes new instance of StringFormatMethodAttribute
            </summary>
      <param name="formatParameterName">Specifies which parameter of an annotated method should be treated as format-string</param>
    </member>
    <member name="P:Lokad.Quality.StringFormatMethodAttribute.FormatParameterName">
      <summary>
            Gets format parameter name
            </summary>
    </member>
    <member name="T:Lokad.Quality.TerminatesProgramAttribute">
      <summary>
            Indicates that the marked method unconditionally terminates control flow execution.
            For example, it could unconditionally throw exception
            </summary>
    </member>
    <member name="T:Lokad.Quality.UsedImplicitlyAttribute">
      <summary>
            Indicates that the marked symbol is used implicitly (ex. reflection, external library), 
            so this symbol will not be marked as unused (as well as by other usage inspections)
            </summary>
      <remarks>This attribute helps R# in code analysis</remarks>
    </member>
    <member name="T:Lokad.Reflection.Express">
      <summary>
            Helper class for the Expression-based strongly-typed reflection
            </summary>
    </member>
    <member name="M:Lokad.Reflection.Express.MethodWithLambda(System.Linq.Expressions.LambdaExpression)">
      <summary>
            Gets the <see cref="T:System.Reflection.MethodInfo" /> 
            from the provided <paramref name="method" />.
            </summary>
      <param name="method">The method expression.</param>
      <returns>method information</returns>
    </member>
    <member name="M:Lokad.Reflection.Express.ConstructorWithLamda(System.Linq.Expressions.LambdaExpression)">
      <summary> Gets the <see cref="T:System.Reflection.ConstructorInfo" /> from the 
            provided <paramref name="constructor" /> lambda. </summary>
      <param name="constructor">The constructor expression.</param>
      <returns>constructor information</returns>
    </member>
    <member name="M:Lokad.Reflection.Express.MemberWithLambda(System.Linq.Expressions.LambdaExpression)">
      <summary> Gets the <see cref="T:System.Reflection.MemberInfo" /> (field or property) 
            from the  provided <paramref name="member" /></summary>
      <param name="member">The property expression.</param>
      <returns>member information</returns>
    </member>
    <member name="M:Lokad.Reflection.Express.PropertyWithLambda(System.Linq.Expressions.LambdaExpression)">
      <summary> Gets the <see cref="T:System.Reflection.PropertyInfo" /> from the provided
            <paramref name="property" /> expression. </summary>
      <param name="property">The property expression.</param>
      <returns>property information</returns>
    </member>
    <member name="M:Lokad.Reflection.Express.FieldWithLambda(System.Linq.Expressions.LambdaExpression)">
      <summary> Gets the <see cref="T:System.Reflection.FieldInfo" /> from the provided 
            <paramref name="field" /> expression. </summary>
      <param name="field">The field expression.</param>
      <returns>field information</returns>
    </member>
    <member name="M:Lokad.Reflection.Express.Method(System.Linq.Expressions.Expression{System.Action})">
      <summary> Gets the <see cref="T:System.Reflection.MethodInfo" /> 
            from the provided <paramref name="method" />.
            </summary>
      <param name="method">The method expression.</param>
      <returns>method information</returns>
    </member>
    <member name="M:Lokad.Reflection.Express.Constructor``1(System.Linq.Expressions.Expression{System.Func{``0}})">
      <summary>
            Gets the <see cref="T:System.Reflection.ConstructorInfo" /> 
            from the provided <paramref name="constructorExpression" />.
            </summary>
      <param name="constructorExpression">The constructor expression.</param>
      <returns>constructor information</returns>
    </member>
    <member name="M:Lokad.Reflection.Express.Property``1(System.Linq.Expressions.Expression{System.Func{``0}})">
      <summary> Gets the <see cref="T:System.Reflection.PropertyInfo" /> from the provided
            <paramref name="property" /> expression. </summary>
      <param name="property">The property expression.</param>
      <returns>property information</returns>
    </member>
    <member name="M:Lokad.Reflection.Express.Field``1(System.Linq.Expressions.Expression{System.Func{``0}})">
      <summary> Gets the <see cref="T:System.Reflection.FieldInfo" /> from the provided 
            <paramref name="field" /> expression. </summary>
      <param name="field">The field expression.</param>
      <returns>field information</returns>
    </member>
    <member name="T:Lokad.Reflection.Express`1">
      <summary>
            Helper class for the Expression-based strongly-typed reflection
            </summary>
    </member>
    <member name="M:Lokad.Reflection.Express`1.Method(System.Linq.Expressions.Expression{System.Action{`0}})">
      <summary> Gets the <see cref="T:System.Reflection.MethodInfo" /> from 
            the provided <paramref name="method" /> expression. </summary>
      <param name="method">The expression.</param>
      <returns>method information</returns>
      <seealso cref="M:Lokad.Reflection.Express.MethodWithLambda(System.Linq.Expressions.LambdaExpression)" />
    </member>
    <member name="M:Lokad.Reflection.Express`1.Property``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary> Gets the <see cref="T:System.Reflection.PropertyInfo" /> from the provided
            <paramref name="property" /> expression. </summary>
      <param name="property">The property expression.</param>
      <returns>property information</returns>
      <seealso cref="M:Lokad.Reflection.Express.MemberWithLambda(System.Linq.Expressions.LambdaExpression)" />
      <seealso cref="M:Lokad.Reflection.Express.PropertyWithLambda(System.Linq.Expressions.LambdaExpression)" />
    </member>
    <member name="M:Lokad.Reflection.Express`1.Field``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary> Gets the <see cref="T:System.Reflection.FieldInfo" /> from the provided 
            <paramref name="field" /> expression. </summary>
      <param name="field">The field expression.</param>
      <returns>field information</returns>
      <seealso cref="M:Lokad.Reflection.Express.MemberWithLambda(System.Linq.Expressions.LambdaExpression)" />
      <seealso cref="M:Lokad.Reflection.Express.FieldWithLambda(System.Linq.Expressions.LambdaExpression)" />
    </member>
    <member name="T:Lokad.Rules.RuleResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Collection_X_cant_be_null">
      <summary>
              Looks up a localized string similar to Collection of type '{0}' should not be null..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Date_must_be_greater_than_X">
      <summary>
              Looks up a localized string similar to Date must be greater than '{0}'..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Double_must_represent_valid_value">
      <summary>
              Looks up a localized string similar to Double should represent a valid value..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Expression_X_must_be_true">
      <summary>
              Looks up a localized string similar to Expression should be true: {0}..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Object_must_be_same_as_reference">
      <summary>
              Looks up a localized string similar to Object should be same as the provided reference..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Object_X_cant_be_null">
      <summary>
              Looks up a localized string similar to Object of type '{0}' should not be null..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.RuleException_header">
      <summary>
              Looks up a localized string similar to Rule messages:.
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.String_cant_be_empty">
      <summary>
              Looks up a localized string similar to String should not be empty..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.String_cant_be_longer_than_X">
      <summary>
              Looks up a localized string similar to String should not be longer than {0} characters..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.String_cant_be_shorter_than_X">
      <summary>
              Looks up a localized string similar to String should not be shorter than {0} characters..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.String_cant_contain_unicode_control_characters">
      <summary>
              Looks up a localized string similar to String should not contain unicode control characters..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.String_cant_contain_X_characters">
      <summary>
              Looks up a localized string similar to String should not contain following characters: {0}..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.String_cant_end_with_whitespace">
      <summary>
              Looks up a localized string similar to String should not end with trailing white-space character..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.String_cant_start_with_whitespace">
      <summary>
              Looks up a localized string similar to String should not start with white-space character..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.String_must_be_valid_email">
      <summary>
              Looks up a localized string similar to String should be a valid email address..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Value_cant_be_equal_to_X">
      <summary>
              Looks up a localized string similar to Value should not be equal to '{0}'..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Value_cant_be_greater_than_X">
      <summary>
              Looks up a localized string similar to Value should not be less than '{0}'..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Value_cant_be_less_than_X">
      <summary>
              Looks up a localized string similar to Value should not be greater than '{0}'..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Value_must_be_equal_to_X">
      <summary>
              Looks up a localized string similar to Value should be equal to '{0}'..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Value_must_be_greater_than_X">
      <summary>
              Looks up a localized string similar to Value should be greater than '{0}'..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Value_must_be_less_than_X">
      <summary>
              Looks up a localized string similar to Value should be less than '{0}'..
            </summary>
    </member>
    <member name="T:Lokad.Rules.RuleAssert`1">
      <summary>
            Helper class to simplify testing of rules.
            </summary>
      <typeparam name="TTarget">The type of the target for rules.</typeparam>
    </member>
    <member name="M:Lokad.Rules.RuleAssert`1.#ctor(Lokad.Rules.Rule{`0}[])">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Rules.RuleAssert`1" /> class.
            </summary>
      <param name="rules">The rules.</param>
    </member>
    <member name="M:Lokad.Rules.RuleAssert`1.ExpectError(`0[])">
      <summary>
            Expects that every single item in <paramref name="testCases" />
            returns <see cref="F:Lokad.Rules.RuleLevel.Error" />.
            </summary>
      <param name="testCases">The test cases.</param>
      <returns>same instance for inlining</returns>
      <exception cref="T:Lokad.Rules.RuleException">when expectation is not met</exception>
    </member>
    <member name="M:Lokad.Rules.RuleAssert`1.ExpectWarn(`0[])">
      <summary>
            Expects that every single item in <paramref name="testCases" />
            returns <see cref="F:Lokad.Rules.RuleLevel.Warn" />.
            </summary>
      <param name="testCases">The test cases.</param>
      <returns>same instance for inlining</returns>
      <exception cref="T:Lokad.Rules.RuleException">when expectation is not met</exception>
    </member>
    <member name="M:Lokad.Rules.RuleAssert`1.ExpectNone(`0[])">
      <summary>
            Expects that every single item in <paramref name="testCases" />
            returns <see cref="F:Lokad.Rules.RuleLevel.None" />.
            </summary>
      <param name="testCases">The test cases.</param>
      <returns>same instance for inlining</returns>
      <exception cref="T:Lokad.Rules.RuleException">when expectation is not met</exception>
    </member>
    <member name="T:Lokad.Rules.RuleAssert">
      <summary> Helper class to simplify testing with rules. </summary>
    </member>
    <member name="M:Lokad.Rules.RuleAssert.For``1(Lokad.Rules.Rule{``0}[])">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Rules.RuleAssert`1" /> class.
            </summary>
      <param name="rules">The rules.</param>
      <typeparam name="TTarget">The type of the target.</typeparam>
      <returns>new instance of the rule tester.</returns>
    </member>
    <member name="M:Lokad.Rules.RuleAssert.IsError``1(``0,Lokad.Rules.Rule{``0}[])">
      <summary>
            Expects that the <paramref name="rules" /> return <see cref="F:Lokad.Rules.RuleLevel.Error" />,
            when executed against the <paramref name="testCase" />.
            </summary>
      <typeparam name="TTarget">The type of the target.</typeparam>
      <param name="testCase">The test case.</param>
      <param name="rules">The rules.</param>
      <exception cref="T:Lokad.Rules.RuleException">when the expectation is not met.</exception>
    </member>
    <member name="M:Lokad.Rules.RuleAssert.IsNone``1(``0,Lokad.Rules.Rule{``0}[])">
      <summary>
            Expects that the <paramref name="rules" /> return <see cref="F:Lokad.Rules.RuleLevel.None" />,
            when executed against the <paramref name="testCase" />.
            </summary>
      <typeparam name="TTarget">The type of the target.</typeparam>
      <param name="testCase">The test case.</param>
      <param name="rules">The rules.</param>
      <exception cref="T:Lokad.Rules.RuleException">when the expectation is not met.</exception>
    </member>
    <member name="M:Lokad.Rules.RuleAssert.IsWarn``1(``0,Lokad.Rules.Rule{``0}[])">
      <summary>
            Expects that the <paramref name="rules" /> return <see cref="F:Lokad.Rules.RuleLevel.Warn" />,
            when executed against the <paramref name="testCase" />.
            </summary>
      <typeparam name="TTarget">The type of the target.</typeparam>
      <param name="testCase">The test case.</param>
      <param name="rules">The rules.</param>
      <exception cref="T:Lokad.Rules.RuleException">when the expectation is not met.</exception>
    </member>
    <member name="M:Lokad.Rules.RuleAssert.That``1(System.Func{``0},System.Linq.Expressions.Expression{System.Predicate{``0}}[])">
      <summary>
            Checks that the specified <paramref name="argumentReference" /> 
            passes the check specified in <paramref name="expressions" /></summary>
      <typeparam name="TTarget">The type of the target.</typeparam>
      <param name="argumentReference">The argument reference.</param>
      <param name="expressions">The expressions to check against.</param>
      <exception cref="T:Lokad.Rules.RuleException">If the check fails</exception>
    </member>
    <member name="M:Lokad.Rules.RuleAssert.IsTrue(System.Linq.Expressions.Expression{System.Func{System.Boolean}})">
      <summary>
            Determines whether the specified expression is true.
            </summary>
      <param name="expression">The expression.</param>
      <exception cref="T:Lokad.Rules.RuleException">if the check fails</exception>
    </member>
    <member name="M:Lokad.Rules.RuleAssert.IsFalse(System.Linq.Expressions.Expression{System.Func{System.Boolean}})">
      <summary>
            Determines whether the specified expression is true.
            </summary>
      <param name="expression">The expression.</param>
    </member>
    <member name="T:Lokad.Rules.IScope">
      <summary>
            Concept from the xLim2. That's simple nesting logger that is used by
            the validation rules. 
            </summary>
      <remarks>
        <para>It has logical the extensibility (not implemented, because there
            does not seem to be any need) for maintaining the error level in
            attached and detached scopes. Warnings, Fatals or Info messages
            could be added here (full ILogScope if needed).</para>
        <para>  Same extensibility
            could be turned on for capturing detailed validation info on complex
            long-running validation scenarios (you'd hate to debug these). </para>
        <para> Note, that in order to maintain .NET 2.0 compatibility,
            is is recommended to use interface-declared methods instead of the
            extensions (or use some extension weaver).</para>
      </remarks>
    </member>
    <member name="M:Lokad.Rules.IScope.Create(System.String)">
      <summary>
            Creates the nested scope with the specified name.
            </summary>
      <param name="name">New name for the nested scope.</param>
      <returns>Nested (and linked) scope instance</returns>
    </member>
    <member name="M:Lokad.Rules.IScope.Write(Lokad.Rules.RuleLevel,System.String)">
      <summary>
            Writes <paramref name="message" /> with the specified
            <paramref name="level" /> to the <see cref="T:Lokad.Rules.IScope" /></summary>
      <param name="level">The level.</param>
      <param name="message">The message.</param>
    </member>
    <member name="P:Lokad.Rules.IScope.Level">
      <summary>
            Gets the current <see cref="T:Lokad.Rules.RuleLevel" /> of this scope
            </summary>
      <value>The level.</value>
    </member>
    <member name="T:Lokad.Rules.ModifierScope">
      <summary>
            Simple <see cref="T:Lokad.Rules.IScope" /> implementation that allows to 
            modify the behavior of the underlying scopes
            </summary>
    </member>
    <member name="T:Lokad.Rules.DelayedScope">
      <summary>
            This scope is just like <see cref="T:Lokad.Rules.SimpleScope" />
            but it delays name resolution
            </summary>
    </member>
    <member name="T:Lokad.Rules.SimpleScope">
      <summary>
        <see cref="T:Lokad.Rules.IScope" /> that maintains scope path, executes 
            <see cref="T:Lokad.Rules.SimpleScope.Messenger" /> delegate per every message.
            </summary>
    </member>
    <member name="T:Lokad.Threading.ParallelExtensions">
      <summary>
             Quick alternatives to PLinq with minimal overhead and simple implementations.
            </summary>
    </member>
    <member name="M:Lokad.Threading.ParallelExtensions.SelectInParallel``2(``0[],System.Func{``0,``1})">
      <summary>Executes the specified function in parallel over an array.</summary>
      <param name="input">Input array to processed in parallel.</param>
      <param name="func">The action to perform. Parameters and all the members should be immutable.</param>
      <remarks>Threads are recycled. Synchronization overhead is minimal.</remarks>
    </member>
    <member name="M:Lokad.Threading.ParallelExtensions.SelectInParallel``2(``0[],System.Func{``0,``1},System.Int32)">
      <summary>
            Executes the specified function in parallel over an array, using the provided number of threads.
            </summary>
      <typeparam name="TItem">The type of the item.</typeparam>
      <typeparam name="TResult">The type of the result.</typeparam>
      <param name="input">Input array to processed in parallel.</param>
      <param name="func">The action to perform. Parameters and all the members should be immutable.</param>
      <param name="threadCount">The thread count.</param>
      <returns>
      </returns>
      <remarks>Threads are recycled. Synchronization overhead is minimal.</remarks>
    </member>
    <member name="P:Lokad.Threading.ParallelExtensions.DefaultThreadCount">
      <summary>Get or sets the default number of threads to be used in
            the parallel extensions. </summary>
    </member>
    <member name="T:Lokad.Threading.WaitFor`1">
      <summary>
            Helper class for invoking tasks with timeout. Overhead is 0,005 ms.
            </summary>
      <typeparam name="TResult">The type of the result.</typeparam>
    </member>
    <member name="M:Lokad.Threading.WaitFor`1.#ctor(System.TimeSpan)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Threading.WaitFor`1" /> class, 
            using the specified timeout for all operations.
            </summary>
      <param name="timeout">The timeout.</param>
    </member>
    <member name="M:Lokad.Threading.WaitFor`1.Run(System.Func{`0})">
      <summary>
            Executes the spcified function within the current thread, aborting it
            if it does not complete within the specified timeout interval. 
            </summary>
      <param name="function">The function.</param>
      <returns>result of the function</returns>
      <remarks>
            The performance trick is that we do not interrupt the current
            running thread. Instead, we just create a watcher that will sleep
            until the originating thread terminates or until the timeout is
            elapsed.
            </remarks>
      <exception cref="T:System.ArgumentNullException">if function is null</exception>
      <exception cref="T:System.TimeoutException">if the function does not finish in time </exception>
    </member>
    <member name="M:Lokad.Threading.WaitFor`1.Run(System.TimeSpan,System.Func{`0})">
      <summary>
            Executes the spcified function within the current thread, aborting it
            if it does not complete within the specified timeout interval.
            </summary>
      <param name="timeout">The timeout.</param>
      <param name="function">The function.</param>
      <returns>result of the function</returns>
      <remarks>
            The performance trick is that we do not interrupt the current
            running thread. Instead, we just create a watcher that will sleep
            until the originating thread terminates or until the timeout is
            elapsed.
            </remarks>
      <exception cref="T:System.ArgumentNullException">if function is null</exception>
      <exception cref="T:System.TimeoutException">if the function does not finish in time </exception>
    </member>
    <member name="T:Lokad.TupleExtensions">
      <summary>
            Helper extensions for tuples
            </summary>
    </member>
    <member name="M:Lokad.TupleExtensions.Append``3(Lokad.Tuple{``0,``1},``2)">
      <summary>
            Appends the specified <paramref name="item" /> to the <paramref name="tuple" />.
            </summary>
      <typeparam name="T1">The type of the first item.</typeparam>
      <typeparam name="T2">The type of the second item.</typeparam>
      <typeparam name="T3">The type of the third item.</typeparam>
      <param name="tuple">The tuple to append to.</param>
      <param name="item">The item to append.</param>
      <returns>New tuple instance</returns>
    </member>
    <member name="M:Lokad.TupleExtensions.Append``4(Lokad.Tuple{``0,``1,``2},``3)">
      <summary>
            Appends the specified <paramref name="item" /> to the <paramref name="tuple" />.
            </summary>
      <typeparam name="T1">The type of the first item.</typeparam>
      <typeparam name="T2">The type of the second item.</typeparam>
      <typeparam name="T3">The type of the third item.</typeparam>
      <typeparam name="T4">The type of the fourth item.</typeparam>
      <param name="tuple">The tuple to append to.</param>
      <param name="item">The item to append.</param>
      <returns>New tuple instance</returns>
    </member>
    <member name="M:Lokad.TupleExtensions.Append``5(Lokad.Tuple{``0,``1,``2,``3},``4)">
      <summary>
            Appends the specified <paramref name="item" /> to the <paramref name="tuple" />.
            </summary>
      <typeparam name="T1">The type of the first item.</typeparam>
      <typeparam name="T2">The type of the second item.</typeparam>
      <typeparam name="T3">The type of the third item.</typeparam>
      <typeparam name="T4">The type of the fourth item.</typeparam>
      <typeparam name="T5">The type of the fifth item.</typeparam>
      <param name="tuple">The tuple to append to.</param>
      <param name="item">The item to append.</param>
      <returns>New tuple instance</returns>
    </member>
    <member name="M:Lokad.TupleExtensions.Add``2(System.Collections.Generic.ICollection{Lokad.Tuple{``0,``1}},``0,``1)">
      <summary> Shortcut to create and add tuple to the collection </summary>
      <typeparam name="T1">The type of the first item.</typeparam>
      <typeparam name="T2">The type of the second item.</typeparam>
      <param name="collection">The collection to add to.</param>
      <param name="first">The first item.</param>
      <param name="second">The second item.</param>
    </member>
    <member name="M:Lokad.TupleExtensions.Add``2(System.Collections.Generic.ICollection{Lokad.Pair{``0,``1}},``0,``1)">
      <summary> Shortcut to create and add tuple to the collection </summary>
      <typeparam name="T1">The type of the first item.</typeparam>
      <typeparam name="T2">The type of the second item.</typeparam>
      <param name="collection">The collection to add to.</param>
      <param name="first">The first item.</param>
      <param name="second">The second item.</param>
    </member>
    <member name="M:Lokad.TupleExtensions.Add``3(System.Collections.Generic.ICollection{Lokad.Tuple{``0,``1,``2}},``0,``1,``2)">
      <summary> Shortcut to create and add tuple to the collection </summary>
      <typeparam name="T1">The type of the first item.</typeparam>
      <typeparam name="T2">The type of the second item.</typeparam>
      <typeparam name="T3">The type of the third item.</typeparam>
      <param name="collection">The collection to add to.</param>
      <param name="first">The first item.</param>
      <param name="second">The second item.</param>
      <param name="third">The third item.</param>
    </member>
    <member name="M:Lokad.TupleExtensions.Add``4(System.Collections.Generic.ICollection{Lokad.Tuple{``0,``1,``2,``3}},``0,``1,``2,``3)">
      <summary> Shortcut to create and add tuple to the collection </summary>
      <typeparam name="T1">The type of the first item.</typeparam>
      <typeparam name="T2">The type of the second item.</typeparam>
      <typeparam name="T3">The type of the third item.</typeparam>
      <typeparam name="T4">The type of the fourth item.</typeparam>
      <param name="collection">The collection to add to.</param>
      <param name="first">The first item.</param>
      <param name="second">The second item.</param>
      <param name="third">The third item.</param>
      <param name="fourth">The fourth item.</param>
    </member>
    <member name="M:Lokad.TupleExtensions.Add``5(System.Collections.Generic.ICollection{Lokad.Tuple{``0,``1,``2,``3,``4}},``0,``1,``2,``3,``4)">
      <summary> Shortcut to create and add tuple to the collection </summary>
      <typeparam name="T1">The type of the first item.</typeparam>
      <typeparam name="T2">The type of the second item.</typeparam>
      <typeparam name="T3">The type of the third item.</typeparam>
      <typeparam name="T4">The type of the fourth item.</typeparam>
      <typeparam name="T5">The type of the fifth item.</typeparam>
      <param name="collection">The collection to add to.</param>
      <param name="first">The first item.</param>
      <param name="second">The second item.</param>
      <param name="third">The third item.</param>
      <param name="fourth">The fourth item.</param>
      <param name="fifth">The fifth item.</param>
    </member>
    <member name="T:Lokad.ArrayUtil">
      <summary>
            Utility class to manipulate arrays of arrays
            </summary>
    </member>
    <member name="F:Lokad.ArrayUtil.EmptyGuid">
      <summary>
            Empty array of <see cref="T:System.Guid" /></summary>
    </member>
    <member name="F:Lokad.ArrayUtil.EmptyInt32">
      <summary>
            Empty array of <see cref="T:System.Int32" /></summary>
    </member>
    <member name="F:Lokad.ArrayUtil.EmptyString">
      <summary>
            Empty array of <see cref="T:System.String" /></summary>
    </member>
    <member name="M:Lokad.ArrayUtil.IsNullOrEmpty(System.Array)">
      <summary>
            Returns <em>True</em> if the provided array is null or empty
            </summary>
      <param name="array">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Lokad.AssemblyUtil">
      <summary>
            Helper class for the managing .NET assemblies
            </summary>
    </member>
    <member name="M:Lokad.AssemblyUtil.GetAssemblyConfiguration">
      <summary>
            Retrieves value of the <see cref="T:System.Reflection.AssemblyConfigurationAttribute" /> for the current assembly
            </summary>
      <returns>
      </returns>
      <exception cref="T:System.InvalidOperationException">When the attribute is missing</exception>
    </member>
    <member name="M:Lokad.AssemblyUtil.GetAssemblyDescription">
      <summary>
            If <see cref="T:System.Reflection.AssemblyDescriptionAttribute" /> is present in the calling assembly, 
            then its value is retrieved. <see cref="F:System.String.Empty" /> is returned otherwise.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Lokad.Container.ComponentAttribute">
      <summary>
             This attribute marks the class for the type-based registration
            </summary>
      <remarks>
             Attribute-based registration is used in cases, when it is
             needed to keep registration properties (i.e. scope) close
             to the component in the code.
             </remarks>
    </member>
    <member name="M:Lokad.Container.ComponentAttribute.#ctor">
      <summary>
            Is used to create type registration
            </summary>
    </member>
    <member name="M:Lokad.Container.ComponentAttribute.#ctor(System.String)">
      <summary>
            Is used to define name-based registration
            </summary>
      <param name="name">Name of the component</param>
    </member>
    <member name="M:Lokad.Container.ComponentAttribute.#ctor(System.Type)">
      <summary>
            Is used to define service-based registration
            </summary>
      <param name="service">Service type</param>
    </member>
    <member name="P:Lokad.Container.ComponentAttribute.Service">
      <summary>
            Service represented by the component
            </summary>
    </member>
    <member name="P:Lokad.Container.ComponentAttribute.Name">
      <summary>
             Name of the component
            </summary>
    </member>
    <member name="P:Lokad.Container.ComponentAttribute.Scope">
      <summary>
            Registration scope for the component
            </summary>
    </member>
    <member name="P:Lokad.Container.ComponentAttribute.Type">
      <summary>
            Registration type for the component
            </summary>
    </member>
    <member name="T:Lokad.Container.DecoratorAttribute">
      <summary>
            This attribute is used by code-gen or DSL tools to mark the decorator class
            </summary>
    </member>
    <member name="M:Lokad.Container.DecoratorAttribute.#ctor(System.Type)">
      <summary>
            Creates new instance of the <see cref="T:Lokad.Container.DecoratorAttribute" /></summary>
      <param name="service">
      </param>
    </member>
    <member name="P:Lokad.Container.DecoratorAttribute.Service">
      <summary>
            Service that is implemented by the decorator
            </summary>
    </member>
    <member name="T:Lokad.Container.DecoratorInfo">
      <summary>
            This class contains the information about some decorator.
            </summary>
    </member>
    <member name="M:Lokad.Container.DecoratorInfo.#ctor(System.Type,System.Type)">
      <summary>
            Create new instance of the <see cref="T:Lokad.Container.DecoratorInfo" /></summary>
      <param name="decoratorClass">
      </param>
      <param name="service">
      </param>
    </member>
    <member name="P:Lokad.Container.DecoratorInfo.DecoratorClass">
      <summary>
            Actual decorator class
            </summary>
    </member>
    <member name="P:Lokad.Container.DecoratorInfo.Service">
      <summary>
            Inner service
            </summary>
    </member>
    <member name="T:Lokad.Container.RegistrationScope">
      <summary>
             Registration scope for the component
            </summary>
    </member>
    <member name="F:Lokad.Container.RegistrationScope.Singleton">
      <summary>
            Component will be created once in the root container
            </summary>
    </member>
    <member name="F:Lokad.Container.RegistrationScope.Container">
      <summary>
            Component will be cached in the current container
            </summary>
    </member>
    <member name="F:Lokad.Container.RegistrationScope.Factory">
      <summary>
            Every component request will return new component
            </summary>
    </member>
    <member name="T:Lokad.Diagnostics.ExceptionCounter">
      <summary>
            Class holding information about exception.
            </summary>
    </member>
    <member name="M:Lokad.Diagnostics.ExceptionCounter.InterlockedIncrement">
      <summary>
            Performs atomic increment of the exception count
            </summary>
    </member>
    <member name="M:Lokad.Diagnostics.ExceptionCounter.#ctor(System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Diagnostics.ExceptionCounter" /> class.
            </summary>
      <param name="firstInstance">The first instance.</param>
    </member>
    <member name="P:Lokad.Diagnostics.ExceptionCounter.ID">
      <summary>
            Gets the unique identifier for the exception.
            </summary>
      <value>The unique identifier for the exception.</value>
    </member>
    <member name="P:Lokad.Diagnostics.ExceptionCounter.FirstInstance">
      <summary>
            Gets the first instance of the exception.
            </summary>
      <value>The first instance.</value>
    </member>
    <member name="P:Lokad.Diagnostics.ExceptionCounter.Count">
      <summary>
            Gets the exception count.
            </summary>
      <value>The count.</value>
    </member>
    <member name="T:Lokad.Diagnostics.ExecutionCounters">
      <summary>
            In-memory thread-safe collection of <see cref="T:Lokad.Diagnostics.ExecutionCounter" /></summary>
    </member>
    <member name="F:Lokad.Diagnostics.ExecutionCounters.Default">
      <summary>
            Default instance of this counter
            </summary>
    </member>
    <member name="M:Lokad.Diagnostics.ExecutionCounters.RegisterRange(System.Collections.Generic.IEnumerable{Lokad.Diagnostics.ExecutionCounter})">
      <summary>
            Registers the execution counters within this collection.
            </summary>
      <param name="counters">The counters.</param>
    </member>
    <member name="M:Lokad.Diagnostics.ExecutionCounters.ToList">
      <summary>
            Retrieves statistics for all exception counters in this collection
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Lokad.Diagnostics.ExecutionCounters.ResetAll">
      <summary>
            Resets all counters.
            </summary>
    </member>
    <member name="T:Lokad.DoubleExtensions">
      <summary>
            Some helper shortcuts for the <see cref="T:System.Double" /></summary>
    </member>
    <member name="M:Lokad.DoubleExtensions.Round(System.Double,System.Int32)">
      <summary>
            Rounds the specified double with the provided number 
            of fractional digits.
            </summary>
      <param name="value">The value to round.</param>
      <param name="digits">The digits.</param>
      <returns>rounded value</returns>
    </member>
    <member name="M:Lokad.DoubleExtensions.Minutes(System.Double)">
      <summary>Returns a <see cref="T:System.TimeSpan" /> that represents a specified number of minutes.</summary>
      <param name="minutes">number of minutes</param>
      <returns>A <see cref="T:System.TimeSpan" /> that represents a value.</returns>
      <example>3D.Minutes()</example>
    </member>
    <member name="M:Lokad.DoubleExtensions.Hours(System.Double)">
      <summary>Returns a <see cref="T:System.TimeSpan" /> that represents a specified number of hours.</summary>
      <param name="hours">number of hours</param>
      <returns>A <see cref="T:System.TimeSpan" /> that represents a value.</returns>
      <example>3D.Hours()</example>
    </member>
    <member name="M:Lokad.DoubleExtensions.Seconds(System.Double)">
      <summary>Returns a <see cref="T:System.TimeSpan" /> that represents a specified number of seconds.</summary>
      <param name="seconds">number of seconds</param>
      <returns>A <see cref="T:System.TimeSpan" /> that represents a value.</returns>
      <example>2D.Seconds()</example>
    </member>
    <member name="M:Lokad.DoubleExtensions.Milliseconds(System.Double)">
      <summary>Returns a <see cref="T:System.TimeSpan" /> that represents a specified number of milliseconds.</summary>
      <param name="milliseconds">milliseconds for this timespan</param>
      <returns>A <see cref="T:System.TimeSpan" /> that represents a value.</returns>
    </member>
    <member name="M:Lokad.DoubleExtensions.Days(System.Double)">
      <summary>
            Returns a <see cref="T:System.TimeSpan" /> that represents a specified number of days.
            </summary>
      <param name="days">Number of days, accurate to the milliseconds.</param>
      <returns>A <see cref="T:System.TimeSpan" /> that represents a value.</returns>
    </member>
    <member name="T:Lokad.Errors">
      <summary>
            Helper class for generating exceptions
            </summary>
    </member>
    <member name="M:Lokad.Errors.KeyInvalid">
      <summary>
            Creates new instance of <see cref="T:Lokad.KeyInvalidException" /></summary>
      <returns>new exception instance</returns>
    </member>
    <member name="M:Lokad.Errors.KeyInvalid(System.Object)">
      <summary>
            Creates new instance of <see cref="T:Lokad.KeyInvalidException" /></summary>
      <param name="value">The value.</param>
      <returns>new exception instance</returns>
    </member>
    <member name="M:Lokad.Errors.Resolution(System.Type,System.Object,System.Exception)">
      <summary>
            Creates new instance of the <see cref="T:Lokad.ResolutionException" /></summary>
      <param name="valueType">Type of the service.</param>
      <param name="key">The service key.</param>
      <param name="inner">The inner.</param>
      <returns>new exception instance</returns>
    </member>
    <member name="M:Lokad.Errors.Resolution(System.Type,System.Exception)">
      <summary>
            Creates new instance of the <see cref="T:Lokad.ResolutionException" /></summary>
      <param name="valueType">Type of the service.</param>
      <param name="inner">The inner.</param>
      <returns>new exception instance</returns>
    </member>
    <member name="M:Lokad.Errors.KeyInvalid(System.Object,System.Exception)">
      <summary>
            Creates new instance of <see cref="T:Lokad.KeyInvalidException" /></summary>
      <param name="value">The value.</param>
      <param name="inner">The inner.</param>
      <returns>new exception instance</returns>
    </member>
    <member name="M:Lokad.Errors.InvalidOperation(System.String,System.Object[])">
      <summary>
            Creates new instance of <see cref="T:System.InvalidOperationException" /></summary>
      <param name="message">The message.</param>
      <param name="args">The arguments of the format string.</param>
      <returns>new exception instance</returns>
    </member>
    <member name="T:Lokad.IDictionaryExtensions">
      <summary>
            Extensions for <see cref="T:System.Collections.Generic.IDictionary`2" /></summary>
    </member>
    <member name="M:Lokad.IDictionaryExtensions.AsProvider``2(System.Collections.Generic.IDictionary{``0,``1})">
      <summary>
            Wraps the dictionary with the read-only provider instance
            </summary>
      <typeparam name="TKey">The type of the key.</typeparam>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="self">The dictionary.</param>
      <returns>provider instance that wraps the dictionary</returns>
    </member>
    <member name="M:Lokad.IDictionaryExtensions.AsProvider``1(System.Collections.Generic.IDictionary{System.String,``0})">
      <summary>
            Wraps the provider with the read-only provider instance
            </summary>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="self">The dictionary.</param>
      <returns>provider instance that wraps the dictionary</returns>
    </member>
    <member name="M:Lokad.IDictionaryExtensions.GetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
      <summary>
            Returns <paramref name="defaultValue" /> if the given <paramref name="key" />
            is not present within the dictionary
            </summary>
      <typeparam name="TKey">The type of the key.</typeparam>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="self">The dictionary.</param>
      <param name="key">The key to look for.</param>
      <param name="defaultValue">The default value.</param>
      <returns>value matching <paramref name="key" /> or <paramref name="defaultValue" /> if none is found</returns>
    </member>
    <member name="M:Lokad.IDictionaryExtensions.GetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
      <summary>
            Gets the value from the <paramref name="dictionary" /> in form of the <see cref="T:Lokad.Maybe`1" />.
            </summary>
      <typeparam name="TKey">The type of the key.</typeparam>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="dictionary">The dictionary.</param>
      <param name="key">The key.</param>
      <returns>value from the dictionary</returns>
    </member>
    <member name="T:Lokad.KeyInvalidException">
      <summary>
            This exception is thrown when the key is not valid (i.e.: not found)
            </summary>
      <remarks> TODO: add proper implementation.</remarks>
    </member>
    <member name="M:Lokad.KeyInvalidException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.KeyInvalidException" /> class.
            </summary>
    </member>
    <member name="M:Lokad.KeyInvalidException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.KeyInvalidException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Lokad.KeyInvalidException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.KeyInvalidException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="inner">The inner.</param>
    </member>
    <member name="M:Lokad.KeyInvalidException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.KeyInvalidException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="info" /> parameter is null.
            </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">
            The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0).
            </exception>
    </member>
    <member name="T:Lokad.DisposableAction">
      <summary>
            Class that allows action to be executed, when it is disposed
            </summary>
    </member>
    <member name="M:Lokad.DisposableAction.#ctor(System.Action)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.DisposableAction" /> class.
            </summary>
      <param name="action">The action.</param>
    </member>
    <member name="M:Lokad.DisposableAction.Dispose">
      <summary>
            Executes the action
            </summary>
    </member>
    <member name="T:Lokad.DebugUtil">
      <summary>
            Helper utility for debugging
            </summary>
    </member>
    <member name="M:Lokad.DebugUtil.SaveTo(System.Object,System.String)">
      <summary>
            Saves the object graph to the specified path.
            </summary>
      <param name="graph">The graph.</param>
      <param name="path">The path to save to.</param>
    </member>
    <member name="M:Lokad.DebugUtil.LoadFrom(System.String)">
      <summary>
            Loads the graph from the specified path.
            </summary>
      <param name="path">The path to load from.</param>
      <returns>graph loaded from the specified path</returns>
    </member>
    <member name="M:Lokad.DebugUtil.LoadFrom``1(System.String)">
      <summary>
            Loads the graph from the specified path.
            </summary>
      <typeparam name="TGraph">The type of the item.</typeparam>
      <param name="path">The path to load from.</param>
      <returns>graph loaded from the specified path</returns>
    </member>
    <member name="T:Lokad.EnumUtil">
      <summary>
            Enum helper class from xLim
            </summary>
    </member>
    <member name="M:Lokad.EnumUtil.Parse``1(System.String)">
      <summary>
            Parses the specified string into the <typeparamref name="TEnum" />, ignoring the case
            </summary>
      <typeparam name="TEnum">The type of the enum.</typeparam>
      <param name="value">The value.</param>
      <returns>Parsed enum</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="value" /> is null</exception>
    </member>
    <member name="T:Lokad.EnumUtil`1">
      <summary>
            Strongly-typed enumeration util
            </summary>
      <typeparam name="TEnum">The type of the enum.</typeparam>
    </member>
    <member name="F:Lokad.EnumUtil`1.Values">
      <summary>
            Values of the <typeparamref name="TEnum" /></summary>
    </member>
    <member name="T:Lokad.Int32Extensions">
      <summary> Extensions to the <see cref="T:System.Int32" /></summary>
    </member>
    <member name="M:Lokad.Int32Extensions.Kb(System.Int32)">
      <summary>
            Returns kilobytes
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Lokad.Int32Extensions.Mb(System.Int32)">
      <summary>
            Returns megabytes
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Lokad.Int32Extensions.Minutes(System.Int32)">
      <summary>Returns a <see cref="T:System.TimeSpan" /> that represents a specified number of minutes.</summary>
      <param name="minutes">number of minutes</param>
      <returns>A <see cref="T:System.TimeSpan" /> that represents a value.</returns>
      <example>3.Minutes()</example>
    </member>
    <member name="M:Lokad.Int32Extensions.Seconds(System.Int32)">
      <summary>
            Returns a <see cref="T:System.TimeSpan" /> that represents a specified number of seconds.
            </summary>
      <param name="seconds">number of seconds</param>
      <returns>A <see cref="T:System.TimeSpan" /> that represents a value.</returns>
      <example>2.Seconds()</example>
    </member>
    <member name="M:Lokad.Int32Extensions.Milliseconds(System.Int32)">
      <summary>
            Returns a <see cref="T:System.TimeSpan" /> that represents a specified number of milliseconds.
            </summary>
      <param name="milliseconds">milliseconds for this timespan</param>
      <returns>A <see cref="T:System.TimeSpan" /> that represents a value.</returns>
    </member>
    <member name="M:Lokad.Int32Extensions.Days(System.Int32)">
      <summary>
            Returns a <see cref="T:System.TimeSpan" /> that represents a specified number of days.
            </summary>
      <param name="days">Number of days.</param>
      <returns>A <see cref="T:System.TimeSpan" /> that represents a value.</returns>
    </member>
    <member name="M:Lokad.Int32Extensions.Hours(System.Int32)">
      <summary>
            Returns a <see cref="T:System.TimeSpan" /> that represents a specified number of hours.
            </summary>
      <param name="hours">Number of hours.</param>
      <returns>A <see cref="T:System.TimeSpan" /> that represents a value.</returns>
    </member>
    <member name="T:Lokad.IProvider`2">
      <summary>
            Interface that abstracts away providers
            </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
      <remarks>
            things like IDataCache (from the Database layers) or IResolver (from the IoC layers) 
            are just samples of this interface
            </remarks>
    </member>
    <member name="M:Lokad.IProvider`2.Get(`0)">
      <summary>
            Retrieves <typeparamref name="TValue" /> given the
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
      <exception cref="T:Lokad.ResolutionException">when the key can not be resolved</exception>
    </member>
    <member name="T:Lokad.IResolver">
      <summary>
            Generic resolution interface for the applications, 
            where proper infrastructure could not be setup
            </summary>
      <remarks>There are no Generic resolution methods 
            (like Resolve(Type service)), for the purpose of enforcing 
            explicit resolution logics </remarks>
    </member>
    <member name="M:Lokad.IResolver.Get``1">
      <summary>
            Resolves this instance.
            </summary>
      <typeparam name="TService">The type of the service.</typeparam>
      <returns>requested instance of <typeparamref name="TService" /></returns>
      <exception cref="T:Lokad.ResolutionException">if there is some resolution problem</exception>
    </member>
    <member name="M:Lokad.IResolver.Get``1(System.String)">
      <summary>
            Resolves the specified service type.
            </summary>
      <typeparam name="TService">The type of the service.</typeparam>
      <param name="name">The name.</param>
      <returns>requested instance of <typeparamref name="TService" /></returns>
      <exception cref="T:Lokad.ResolutionException">if there is resolution problem</exception>
    </member>
    <member name="T:Lokad.Lambda`1">
      <summary>
            Helper class for creating lambda expressions that return
            anonymous types
            </summary>
      <typeparam name="T1">The type of the first argument.</typeparam>
    </member>
    <member name="M:Lokad.Lambda`1.Func``1(System.Func{`0,``0})">
      <summary>
            Returns the provided function.
            </summary>
      <typeparam name="TResult">The type of the result.</typeparam>
      <param name="func">The func.</param>
      <returns>returns the same function instance</returns>
    </member>
    <member name="T:Lokad.Lambda">
      <summary>
            Helper class for creating lambda expressions that return
            anonymous types
            </summary>
    </member>
    <member name="M:Lokad.Lambda.Func``1(System.Func{``0})">
      <summary>
            Returns the provided function
            </summary>
      <typeparam name="TResult">The type of the result.</typeparam>
      <param name="func">The function.</param>
      <returns>returns same function instance</returns>
    </member>
    <member name="M:Lokad.Lambda.Action``1(System.Action{``0})">
      <summary>
            Returns the provided action
            </summary>
      <param name="action">The action.</param>
      <returns>returns same action instance</returns>
    </member>
    <member name="T:Lokad.INamedProvider`1">
      <summary>
            Shortcut interface for <see cref="T:Lokad.IProvider`2" /> that uses <see cref="T:System.String" /> as the key.
            </summary>
      <typeparam name="TValue">
      </typeparam>
    </member>
    <member name="T:Lokad.NamedProvider`1">
      <summary>
            This class provides way to create providers out of lambda shortcuts
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Lokad.NamedProvider`1.#ctor(System.Func{System.String,`0})">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.NamedProvider`1" /> class.
            </summary>
      <param name="resolver">The resolver.</param>
    </member>
    <member name="M:Lokad.NamedProvider`1.Get(System.String)">
      <summary>
            Retrieves <typeparamref name="T" /> given the <paramref name="key" /></summary>
      <param name="key">
      </param>
      <returns>
      </returns>
      <exception cref="T:Lokad.ResolutionException">when the key cannot be resolved</exception>
    </member>
    <member name="T:Lokad.NamedProvider">
      <summary>
            Shortcuts for <see cref="T:Lokad.NamedProvider`1" /></summary>
    </member>
    <member name="M:Lokad.NamedProvider.For``1(System.Func{System.String,``0})">
      <summary>
            Creates new instance of the <see cref="T:Lokad.INamedProvider`1" /> out of
            the provider function (shortcut syntax)
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="providerFunction">The provider function.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Lokad.Provider`2">
      <summary>
            This class provides short-cut for creating providers
            out of lambda expressions.
            </summary>
      <typeparam name="TKey">The type of the key.</typeparam>
      <typeparam name="TValue">The type of the value.</typeparam>
    </member>
    <member name="M:Lokad.Provider`2.#ctor(System.Func{`0,`1})">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Provider`2" /> class.
            </summary>
      <param name="resolver">The resolver.</param>
      <exception cref="T:System.ArgumentNullException">When 
            <paramref name="resolver" /> is null</exception>
    </member>
    <member name="M:Lokad.Provider`2.Get(`0)">
      <summary>
            Retrieves <typeparamref name="TValue" /> given the
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
      <exception cref="T:Lokad.ResolutionException">when the key is invalid for
            the provider</exception>
    </member>
    <member name="T:Lokad.Provider`1">
      <summary>
            Helper class that simplifies creation of <see cref="T:Lokad.Provider`2" /></summary>
      <typeparam name="TKey">type of the Key items</typeparam>
    </member>
    <member name="M:Lokad.Provider`1.For``1(System.Func{`0,``0})">
      <summary>
            Creates the provider, letting compiler to figure out
            the value type. This allows to use anonymous types locally as well
            </summary>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="func">The function that is the provider.</param>
      <returns>new provider instance</returns>
    </member>
    <member name="T:Lokad.Tuple`4">
      <summary>
            Tuple class with 4 items (also called <em>Quadruple</em>)
            </summary>
      <typeparam name="T1">The type of the first item.</typeparam>
      <typeparam name="T2">The type of the second item.</typeparam>
      <typeparam name="T3">The type of the third item.</typeparam>
      <typeparam name="T4">The type of the fourth item.</typeparam>
    </member>
    <member name="M:Lokad.Tuple`4.#ctor(`0,`1,`2,`3)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Tuple`4" /> class.
            </summary>
      <param name="first">The first item.</param>
      <param name="second">The second item.</param>
      <param name="third">The third item.</param>
      <param name="fourth">The fourth item.</param>
    </member>
    <member name="M:Lokad.Tuple`4.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:Lokad.Tuple`4" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:Lokad.Tuple`4" />.
            </returns>
    </member>
    <member name="M:Lokad.Tuple`4.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:Lokad.Tuple`4" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:Lokad.Tuple`4" />.</param>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:Lokad.Tuple`4" />; otherwise, false.
            </returns>
      <exception cref="T:System.NullReferenceException">
            The <paramref name="obj" /> parameter is null.
            </exception>
    </member>
    <member name="M:Lokad.Tuple`4.Equals(Lokad.Tuple{`0,`1,`2,`3})">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <returns>
            true if the current object is equal to the <paramref name="obj" /> parameter; otherwise, false.
            </returns>
      <param name="obj">
            An object to compare with this object.
            </param>
    </member>
    <member name="M:Lokad.Tuple`4.GetHashCode">
      <summary>
            Serves as a hash function for a particular type. 
            </summary>
      <returns>
            A hash code for the current <see cref="T:Lokad.Tuple`4" />.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:Lokad.Tuple`4.op_Equality(Lokad.Tuple{`0,`1,`2,`3},Lokad.Tuple{`0,`1,`2,`3})">
      <summary>
            Implements the operator ==.
            </summary>
      <param name="left">The left.</param>
      <param name="right">The right.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Lokad.Tuple`4.op_Inequality(Lokad.Tuple{`0,`1,`2,`3},Lokad.Tuple{`0,`1,`2,`3})">
      <summary>
            Implements the operator !=.
            </summary>
      <param name="left">The left.</param>
      <param name="right">The right.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="P:Lokad.Tuple`4.Item1">
      <summary>
            Gets or sets the item1.
            </summary>
      <value>The item1.</value>
    </member>
    <member name="P:Lokad.Tuple`4.Item2">
      <summary>
            Gets or sets the item2.
            </summary>
      <value>The item2.</value>
    </member>
    <member name="P:Lokad.Tuple`4.Item3">
      <summary>
            Gets or sets the item3.
            </summary>
      <value>The item3.</value>
    </member>
    <member name="P:Lokad.Tuple`4.Item4">
      <summary>
            Gets or sets the item4.
            </summary>
      <value>The item4.</value>
    </member>
    <member name="T:Lokad.Quad`4">
      <summary>
            Tuple class with 4 items (also called <em>Quadruple</em>)
            </summary>
      <typeparam name="T1">The type of the first item.</typeparam>
      <typeparam name="T2">The type of the second item.</typeparam>
      <typeparam name="T3">The type of the third item.</typeparam>
      <typeparam name="T4">The type of the fourth item.</typeparam>
    </member>
    <member name="M:Lokad.Quad`4.#ctor(`0,`1,`2,`3)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Quad`4" /> class.
            </summary>
      <param name="first">The first item.</param>
      <param name="second">The second item.</param>
      <param name="third">The third item.</param>
      <param name="fourth">The fourth item.</param>
    </member>
    <member name="T:Lokad.Rand">
      <summary>
            Helper class that allows to implement non-deterministic 
            reproducible testing.
            </summary>
      <remarks>
            Keep in mind, that this implementation is not thread-safe.
            </remarks>
    </member>
    <member name="M:Lokad.Rand.ResetToDefault">
      <summary>
            Resets everything to the default.
            </summary>
    </member>
    <member name="M:Lokad.Rand.Reset">
      <summary>
            Resets the random generator, using the provided activator
            </summary>
    </member>
    <member name="M:Lokad.Rand.Reset(System.Func{System.Func{System.Int32,System.Int32}})">
      <summary>
            Overrides with the current activator
            </summary>
      <param name="activator">The activator.</param>
    </member>
    <member name="M:Lokad.Rand.Next">
      <summary>
            Generates random value between 0 and <see cref="F:System.Int32.MaxValue" /> (exclusive)
            </summary>
      <returns>random integer</returns>
    </member>
    <member name="M:Lokad.Rand.Next(System.Int32)">
      <summary>
            Generates random value between 0 and <paramref name="upperBound" /> (exclusive)
            </summary>
      <param name="upperBound">The upper bound.</param>
      <returns>random integer</returns>
    </member>
    <member name="M:Lokad.Rand.Next(System.Int32,System.Int32)">
      <summary>
            Generates random value between <paramref name="lowerBound" />
            and <paramref name="upperBound" /> (exclusive)
            </summary>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <returns>random integer</returns>
    </member>
    <member name="M:Lokad.Rand.NextItem``1(``0[])">
      <summary> Picks random item from the provided array </summary>
      <typeparam name="TItem">The type of the item.</typeparam>
      <param name="items">The items.</param>
      <returns>random item from the array</returns>
    </member>
    <member name="M:Lokad.Rand.NextEnum``1">
      <summary> Picks random <see cref="T:System.Enum" /></summary>
      <typeparam name="TEnum">The type of the enum.</typeparam>
      <returns>random Enum value</returns>
    </member>
    <member name="M:Lokad.Rand.NextGuid">
      <summary>
            Picks random <see cref="T:System.Guid" /></summary>
      <returns>random value</returns>
    </member>
    <member name="M:Lokad.Rand.NextDouble">
      <summary> Returns random double value with lowered precision </summary>
      <returns>random double value</returns>
    </member>
    <member name="M:Lokad.Rand.NextDate">
      <summary>
            Returns a random date between 1700-01-01 and 2100-01-01
            </summary>
      <returns>random value</returns>
    </member>
    <member name="M:Lokad.Rand.NextString(System.Int32,System.Int32)">
      <summary>
            Generates random string with the length between 
            <paramref name="lowerBound" /> and <paramref name="upperBound" /> (exclusive)
            </summary>
      <param name="lowerBound">The lower bound for the string length.</param>
      <param name="upperBound">The upper bound for the string length.</param>
      <returns>new random string</returns>
    </member>
    <member name="M:Lokad.Rand.NextItems``1(``0[],System.Int32)">
      <summary>
            Gets a random subset from the array
            </summary>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="items">The items.</param>
      <param name="count">The count.</param>
      <returns>array that contains <paramref name="count" /> items from the original array</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">when <paramref name="count" /> 
            is bigger than the length of <paramref name="items" /></exception>
    </member>
    <member name="T:Lokad.Range">
      <summary>
            Helper class with shortcut methods for managing enumerations.
            Useful for inlining object generation in tests
            </summary>
    </member>
    <member name="M:Lokad.Range.Empty``1">
      <summary> Returns empty enumerator </summary>
      <typeparam name="T">type of the item to enumerate</typeparam>
      <returns>singleton instance of the empty enumerator</returns>
    </member>
    <member name="M:Lokad.Range.Create(System.Int32)">
      <summary>
            returns enumeration from 0 with <paramref name="count" /> numbers
            </summary>
      <param name="count">Number of items to create</param>
      <returns>enumerable</returns>
    </member>
    <member name="M:Lokad.Range.Create(System.Int32,System.Int32)">
      <summary>
            Creates sequence of the integral numbers within the specified range
            </summary>
      <param name="start">The value of the first integer in sequence.</param>
      <param name="count">The number of values in the sequence.</param>
      <returns>sequence of the integral numbers within the specified range</returns>
    </member>
    <member name="M:Lokad.Range.Repeat``1(``0,System.Int32)">
      <summary>
            Creates sequence that consists of a repeated value.
            </summary>
      <typeparam name="TResult">The type of the value to repeat.</typeparam>
      <param name="item">The value to repeat.</param>
      <param name="count">The number of times to repeat.</param>
      <returns>sequence that consists of a repeated value</returns>
    </member>
    <member name="M:Lokad.Range.Create``1(System.Func{System.Int32,``0})">
      <summary>
            Creates the generator to iterate from 1 to <see cref="F:System.Int32.MaxValue" />.
            </summary>
      <typeparam name="T">type of the item to generate</typeparam>
      <param name="generator">The generator.</param>
      <returns>new enumerator</returns>
    </member>
    <member name="M:Lokad.Range.Create``1(System.Int32,System.Func{System.Int32,``0})">
      <summary>
            Creates the enumerable using the provided generator.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="count">The count.</param>
      <param name="generator">The generator.</param>
      <returns>enumerable instance</returns>
    </member>
    <member name="M:Lokad.Range.Create``1(System.Int32,System.Func{``0})">
      <summary>
            Creates the enumerable using the provided generator.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="count">The count.</param>
      <param name="generator">The generator.</param>
      <returns>enumerable instance</returns>
    </member>
    <member name="M:Lokad.Range.Array``1(System.Int32,System.Func{System.Int32,``0})">
      <summary>
            Creates the array populated with the provided generator
            </summary>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="count">The count.</param>
      <param name="generator">The generator.</param>
      <returns>array</returns>
    </member>
    <member name="M:Lokad.Range.Array(System.Int32)">
      <summary>
            Creates the array of integers
            </summary>
      <param name="count">The count.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Lokad.ResolutionException">
      <summary>
            Exception that is thrown by <see cref="T:Lokad.IResolver" /> or <see cref="T:Lokad.IProvider`2" /></summary>
    </member>
    <member name="M:Lokad.ResolutionException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.ResolutionException" /> class.
            </summary>
    </member>
    <member name="M:Lokad.ResolutionException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.ResolutionException" /> class.
            </summary>
      <param name="message">The message related to this exception.</param>
    </member>
    <member name="M:Lokad.ResolutionException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.ResolutionException" /> class.
            </summary>
      <param name="message">The message related to this exception.</param>
      <param name="inner">The inner exception.</param>
    </member>
    <member name="M:Lokad.ResolutionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.ResolutionException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="info" /> parameter is null.
            </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">
            The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0).
            </exception>
    </member>
    <member name="T:Lokad.Resolver">
      <summary>
            Implementation of the <see cref="T:Lokad.IResolver" /> that uses delegates
            to wire up the resolution logics and wraps all exceptions with the
            <see cref="T:Lokad.ResolutionException" /></summary>
    </member>
    <member name="M:Lokad.Resolver.#ctor(System.Func{System.Type,System.Object},System.Func{System.Type,System.String,System.Object})">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Resolver" /> class.
            </summary>
      <param name="resolver">The resolver.</param>
      <param name="namedResolver">The named resolver.</param>
    </member>
    <member name="M:Lokad.Resolver.Get``1">
      <summary>
            Resolves this instance.
            </summary>
      <typeparam name="TService">The type of the service.</typeparam>
      <returns>
            requested instance of <typeparamref name="TService" /></returns>
      <exception cref="T:Lokad.ResolutionException">if there is some resolution problem</exception>
    </member>
    <member name="M:Lokad.Resolver.Get``1(System.String)">
      <summary>
            Resolves the specified service type.
            </summary>
      <typeparam name="TService">The type of the service.</typeparam>
      <param name="name">The name.</param>
      <returns>
            requested instance of <typeparamref name="TService" /></returns>
      <exception cref="T:Lokad.ResolutionException">if there is resolution problem</exception>
    </member>
    <member name="T:Lokad.ResourceUtil`1">
      <summary>
            Simple helper class to replace common "DataMother" helper
            used in tests.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Lokad.ResourceUtil`1.GetStream(System.String)">
      <summary>
            Gets the stream for the associated resource from the <typeparamref name="T" />
            namespace.
            </summary>
      <seealso cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <param name="name">The name of the resource.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Lokad.Data.SqlClient.SqlServerGuidComparer">
      <summary>
            This class compares two guids according to the SQL server ordering rules.
            </summary>
    </member>
    <member name="F:Lokad.Data.SqlClient.SqlServerGuidComparer.Instance">
      <summary>
            Singleton instance of the <see cref="T:Lokad.Data.SqlClient.SqlServerGuidComparer" /></summary>
    </member>
    <member name="M:Lokad.Data.SqlClient.SqlServerGuidComparer.Compare(System.Guid,System.Guid)">
      <summary>
            Compares two guids and returns a value indicating whether one is less than, equal to, or greater than the other.
            </summary>
      <param name="x">The first guid to compare.</param>
      <param name="y">The second guid to compare.</param>
      <returns>
            Value indicating relation between x and y
            </returns>
    </member>
    <member name="T:Lokad.Result`1">
      <summary>
            Helper class that allows to pass out method call results without using exceptions
            </summary>
      <typeparam name="T">type of the associated data</typeparam>
    </member>
    <member name="M:Lokad.Result`1.Error(System.String)">
      <summary> Creates failure result </summary>
      <param name="errorMessage">error message</param>
      <returns>result that is a failure</returns>
    </member>
    <member name="M:Lokad.Result`1.Error(System.String,System.Object[])">
      <summary>  Creates failure result </summary>
      <param name="errorFormatString">format string for the error message</param>
      <param name="args">The arguments.</param>
      <returns>result that is a failure</returns>
    </member>
    <member name="M:Lokad.Result`1.Success(`0)">
      <summary>
            Creates success result
            </summary>
      <param name="value">item associated with the success result</param>
      <returns>result that is a success</returns>
      <exception cref="T:System.ArgumentNullException">if <paramref name="value" /> is a reference type that is null</exception>
    </member>
    <member name="M:Lokad.Result`1.op_Implicit(`0)~Lokad.Result{`0}">
      <summary>
            Performs an implicit conversion from <typeparamref name="T" /> to <see cref="T:Lokad.Result`1" />.
            </summary>
      <param name="value">The item.</param>
      <returns>The result of the conversion.</returns>
      <exception cref="T:System.ArgumentNullException">if <paramref name="value" /> is a reference type that is null</exception>
    </member>
    <member name="M:Lokad.Result`1.Apply(System.Action{`0})">
      <summary>
            Applies the specified <paramref name="action" />
            to this <see cref="T:Lokad.Result`1" />, if it has value.
            </summary>
      <param name="action">The action to apply.</param>
      <exception cref="T:System.ArgumentNullException">if <paramref name="action" /> is null</exception>
    </member>
    <member name="M:Lokad.Result`1.Convert``1(System.Func{`0,``0})">
      <summary>
            Converts value of this instance
            using the provided <paramref name="converter" /></summary>
      <typeparam name="TTarget">The type of the target.</typeparam>
      <param name="converter">The converter.</param>
      <returns>Converted result</returns>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="converter" /> is null</exception>
    </member>
    <member name="M:Lokad.Result`1.Equals(Lokad.Result{`0})">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <param name="other">An object to compare with this object.</param>
      <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
    </member>
    <member name="M:Lokad.Result`1.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
      <exception cref="T:System.NullReferenceException">
            The <paramref name="obj" /> parameter is null.
            </exception>
    </member>
    <member name="M:Lokad.Result`1.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Lokad.Result`1.Combine``1(System.Func{`0,Lokad.Result{``0}})">
      <summary>
            Combines this <see cref="T:Lokad.Result`1" /> with the result returned
            by <paramref name="converter" />.
            </summary>
      <typeparam name="TTarget">The type of the target.</typeparam>
      <param name="converter">The converter.</param>
      <returns>Combined result.</returns>
    </member>
    <member name="M:Lokad.Result`1.ToMaybe``1(System.Func{`0,``0})">
      <summary>
            Converts this <see cref="T:Lokad.Result`1" /> to <see cref="T:Lokad.Maybe`1" />, 
            using the <paramref name="converter" /> to perform the value conversion.
            </summary>
      <typeparam name="TTarget">The type of the target.</typeparam>
      <param name="converter">The reflector.</param>
      <returns>
        <see cref="T:Lokad.Maybe`1" /> that represents the original value behind the <see cref="T:Lokad.Result`1" /> after the conversion</returns>
    </member>
    <member name="P:Lokad.Result`1.IsSuccess">
      <summary>
            Gets a value indicating whether this result is valid.
            </summary>
      <value>
        <c>true</c> if this result is valid; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Lokad.Result`1.Value">
      <summary>
            item associated with this result
            </summary>
    </member>
    <member name="P:Lokad.Result`1.ErrorMessage">
      <summary>
            Error message associated with this failure
            </summary>
    </member>
    <member name="T:Lokad.Result">
      <summary> Helper class for creating <see cref="T:Lokad.Result`1" /> instances </summary>
    </member>
    <member name="M:Lokad.Result.Success``1(``0)">
      <summary> Creates success result </summary>
      <typeparam name="TResult">The type of the result.</typeparam>
      <param name="value">The item.</param>
      <returns>new result instance</returns>
      <seealso cref="M:Lokad.Result`1.Success(`0)" />
    </member>
    <member name="T:Lokad.Rules.DoubleIs">
      <summary>
            Rules for the <see cref="T:System.Double" /></summary>
    </member>
    <member name="M:Lokad.Rules.DoubleIs.Valid(System.Double,Lokad.Rules.IScope)">
      <summary>
            Checks if the specified double is valid.
            </summary>
      <param name="value">The value.</param>
      <param name="scope">The scope.</param>
    </member>
    <member name="T:Lokad.Rules.RuleMessages">
      <summary>
            Collection of messages with the associated highest level
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleMessages.Level">
      <summary>
            The highest level within the collection
            </summary>
      <value>The level.</value>
    </member>
    <member name="P:Lokad.Rules.RuleMessages.IsError">
      <summary>
            Gets a value indicating whether this instance has a message 
            of  <see cref="F:Lokad.Rules.RuleLevel.Error" /> or higher.
            </summary>
      <value>
        <c>true</c> if this instance has message of 
            <see cref="F:Lokad.Rules.RuleLevel.Error" /> or higher ; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Lokad.Rules.RuleMessages.IsWarn">
      <summary>
            Gets a value indicating whether this instance has a message 
            of <see cref="F:Lokad.Rules.RuleLevel.Warn" /> or higher.
            </summary>
      <value>
        <c>true</c> if this instance has message of 
            <see cref="F:Lokad.Rules.RuleLevel.Warn" /> or higher ; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Lokad.Rules.RuleMessages.IsSuccess">
      <summary>
            Gets a value indicating whether this instance does not have any messages
            of <see cref="F:Lokad.Rules.RuleLevel.Warn" /> or higher
            </summary>
      <value>
        <c>true</c> if this instance does not have any messages
            of <see cref="F:Lokad.Rules.RuleLevel.Warn" /> or higher; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Lokad.Rules.Rule`1">
      <summary>
             Typed delegate for holding the validation logics
            </summary>
      <param name="obj">Object to validate</param>
      <param name="scope">Scope that will hold all validation results</param>
      <typeparam name="T">type of the item to validate</typeparam>
    </member>
    <member name="T:Lokad.Rules.RuleException">
      <summary>
            Exception that is thrown when some validation error is encountered
            </summary>
      <remarks>
            TODO: add proper implementation
            </remarks>
    </member>
    <member name="M:Lokad.Rules.RuleException.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Rules.RuleException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="reference">The reference.</param>
    </member>
    <member name="M:Lokad.Rules.RuleException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Rules.RuleException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Lokad.Rules.RuleException.#ctor(System.Collections.Generic.IEnumerable{Lokad.Rules.RuleMessage})">
      <summary> Initializes a new instance of the <see cref="T:Lokad.Rules.RuleException" /> class. </summary>
      <param name="messages">The messages.</param>
    </member>
    <member name="M:Lokad.Rules.RuleException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Rules.RuleException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="info" /> parameter is null.
            </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">
            The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0).
            </exception>
    </member>
    <member name="T:Lokad.Rules.DateIs">
      <summary> Rules for the <see cref="T:System.DateTime" /></summary>
    </member>
    <member name="M:Lokad.Rules.DateIs.SqlCompatible(System.DateTime,Lokad.Rules.IScope)">
      <summary>
            Verifies that it is ok to send this date directly into the MS SQL DB
            </summary>
      <param name="dateTime">The dateTime to validate.</param>
      <param name="scope">validation scope</param>
    </member>
    <member name="T:Lokad.Rules.Is">
      <summary>
            Generic rules 
            </summary>
    </member>
    <member name="M:Lokad.Rules.Is.NotEqual``1(System.IEquatable{``0})">
      <summary>
            Composes the validator ensuring that the provided value does not equal to <paramref name="item" /></summary>
      <typeparam name="T">type of the item to compare</typeparam>
      <param name="item">The item.</param>
      <returns>new rule instance</returns>
    </member>
    <member name="M:Lokad.Rules.Is.Equal``1(System.IEquatable{``0})">
      <summary>
            Composes the validator ensuring that the provided value equals to <paramref name="item" /></summary>
      <typeparam name="T">type of the item to compare</typeparam>
      <param name="item">The item.</param>
      <returns>new rule instance</returns>
    </member>
    <member name="M:Lokad.Rules.Is.Value``1(``0)">
      <summary>
            Composes the validator ensuring that the provided value equals to <paramref name="item" /></summary>
      <typeparam name="T">type of the item to compare</typeparam>
      <param name="item">The item.</param>
      <returns>new rule instance</returns>
    </member>
    <member name="M:Lokad.Rules.Is.SameAs``1(``0)">
      <summary>
            Composes the validator ensuring that the provided object is same as <paramref name="item" /></summary>
      <typeparam name="T">type of the item to compare</typeparam>
      <param name="item">The item.</param>
      <returns>new rule instance</returns>
    </member>
    <member name="M:Lokad.Rules.Is.NotDefault``1(``0,Lokad.Rules.IScope)">
      <summary>
            Returns error if the provided value type has default value
            </summary>
      <typeparam name="T">value type to check</typeparam>
      <param name="item">The item.</param>
      <param name="scope">The scope.</param>
    </member>
    <member name="M:Lokad.Rules.Is.Default``1(``0,Lokad.Rules.IScope)">
      <summary>
            Returns error if provided value type has been initialized
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="item">The item.</param>
      <param name="scope">The scope.</param>
    </member>
    <member name="M:Lokad.Rules.Is.Within``1(System.IComparable{``0},System.IComparable{``0})">
      <summary>
            Composes the range validator that ensures that the supplied value belongs
            to the interval from <paramref name="minValue" /> to <paramref name="maxValue" />
            (inclusive).
            </summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="minValue">The min value.</param>
      <param name="maxValue">The max value.</param>
      <returns>new validator instance</returns>
    </member>
    <member name="M:Lokad.Rules.Is.Between``1(System.IComparable{``0},System.IComparable{``0})">
      <summary>
            Composes the range validator that ensures that the supplied value belongs
            to the interval between <paramref name="lowerBound" /> and <paramref name="upperBound" />
            (exclusive)
            </summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <returns>new rule instance</returns>
    </member>
    <member name="M:Lokad.Rules.Is.GreaterThan``1(System.IComparable{``0})">
      <summary>
            Creates the rule to ensure that the validated value is greater than
            the specified <paramref name="comparable" /></summary>
      <typeparam name="T">type of the item to run rule against</typeparam>
      <param name="comparable">The comparable.</param>
      <returns>new rule instance</returns>
    </member>
    <member name="M:Lokad.Rules.Is.AtLeast``1(System.IComparable{``0})">
      <summary>
            Creates the rule to ensure that the validated value is greater than
            or equal to the specified <paramref name="comparable" /></summary>
      <typeparam name="T">type of the item to run rule against</typeparam>
      <param name="comparable">The comparable.</param>
      <returns>new rule instance</returns>
    </member>
    <member name="M:Lokad.Rules.Is.AtMost``1(System.IComparable{``0})">
      <summary>
            Creates the rule to ensure that the validated value is less than
            or equal to the specified <paramref name="comparable" /></summary>
      <typeparam name="T">type of the item to run rule against</typeparam>
      <param name="comparable">The comparable.</param>
      <returns>new rule instance</returns>
    </member>
    <member name="M:Lokad.Rules.Is.LessThan``1(System.IComparable{``0})">
      <summary>
            Creates the rule to ensure that the validated value is less than
            the specified <paramref name="comparable" /></summary>
      <typeparam name="T">type of the item to run rule against</typeparam>
      <param name="comparable">The comparable.</param>
      <returns>new rule instance</returns>
    </member>
    <member name="M:Lokad.Rules.Is.True``1(System.Linq.Expressions.Expression{System.Predicate{``0}})">
      <summary>
        <para>Compiles the rule out of the specified expression.</para>
      </summary>
      <typeparam name="TTarget">The type of the target.</typeparam>
      <param name="expression">The expression.</param>
      <returns>compiled rule instance</returns>
    </member>
    <member name="T:Lokad.Rules.RuleLevel">
      <summary>
            Levels leveraged by the <see cref="T:Lokad.Rules.Rule`1" /> implementations
            </summary>
    </member>
    <member name="F:Lokad.Rules.RuleLevel.None">
      <summary> Default value for the purposes of good citizenship </summary>
    </member>
    <member name="F:Lokad.Rules.RuleLevel.Warn">
      <summary> The rule raises a warning </summary>
    </member>
    <member name="F:Lokad.Rules.RuleLevel.Error">
      <summary> The rule raises an error </summary>
    </member>
    <member name="T:Lokad.Rules.RuleMessage">
      <summary> Rule message </summary>
    </member>
    <member name="M:Lokad.Rules.RuleMessage.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="P:Lokad.Rules.RuleMessage.Path">
      <summary>
            Gets the object path for the current message.
            </summary>
      <value>The path object path.</value>
    </member>
    <member name="P:Lokad.Rules.RuleMessage.Level">
      <summary>
            Gets the <see cref="T:Lokad.Rules.RuleLevel" /> associated with this message.
            </summary>
      <value>The level.</value>
    </member>
    <member name="P:Lokad.Rules.RuleMessage.Message">
      <summary>
            Gets the message.
            </summary>
      <value>The message.</value>
    </member>
    <member name="T:Lokad.Rules.StringIs">
      <summary>
            Common string rules
            </summary>
    </member>
    <member name="F:Lokad.Rules.StringIs._emailRegex">
      <summary>
            Originally http://fightingforalostcause.net/misc/2006/compare-email-regex.php,
            but modified to have less negative results 
            </summary>
    </member>
    <member name="F:Lokad.Rules.StringIs.NotEmpty">
      <summary>
            Reports error if the associated string is empty
            </summary>
    </member>
    <member name="F:Lokad.Rules.StringIs.ValidForXmlSerialization">
      <summary>
            String validator that detects possible issues 
            for passing strings through the ASP.NET Web services
            </summary>
    </member>
    <member name="F:Lokad.Rules.StringIs.WithoutLeadingWhiteSpace">
      <summary> String validator checking for presence of 
            white-space characters in the beginning of string </summary>
    </member>
    <member name="F:Lokad.Rules.StringIs.WithoutTrailingWhiteSpace">
      <summary> String validator checking for presence of 
            white-space characters in the end of string </summary>
    </member>
    <member name="M:Lokad.Rules.StringIs.ValidEmail(System.String,Lokad.Rules.IScope)">
      <summary>
            Determines whether the string is valid email address
            </summary>
      <param name="email">string to validate</param>
      <param name="scope">validation scope.</param>
    </member>
    <member name="M:Lokad.Rules.StringIs.Limited(System.Int32,System.Int32)">
      <summary>
            Composes the string validator ensuring string length is within the supplied rangs
            </summary>
      <param name="minLength">Min string length.</param>
      <param name="maxLength">Max string length.</param>
      <returns>new validator instance</returns>
    </member>
    <member name="M:Lokad.Rules.StringIs.Limited(System.Int32)">
      <summary>
            Composes the string validator ensuring string length is shorter than
            <paramref name="maxLength" /></summary>
      <param name="maxLength">Max string length.</param>
      <returns>new validator instance</returns>
    </member>
    <member name="M:Lokad.Rules.StringIs.Without(System.Char[])">
      <summary>
            String validator that ensures absence of any illegal characters
            </summary>
      <param name="illegalCharacters">The illegal characters.</param>
      <returns>new validator instance</returns>
    </member>
    <member name="T:Lokad.Rules.Scope">
      <summary>
            Helper class that invokes different scopes
            </summary>
    </member>
    <member name="M:Lokad.Rules.Scope.WhenError(Lokad.Rules.RuleLevel)">
      <summary>
            Returns true if <paramref name="level" />
            is <see cref="F:Lokad.Rules.RuleLevel.Error" /> or higher
            </summary>
      <param name="level">The level to check.</param>
      <returns>true if the condition is met</returns>
    </member>
    <member name="M:Lokad.Rules.Scope.WhenAny(Lokad.Rules.RuleLevel)">
      <summary>
            Returns true if <paramref name="level" />
            is not <see cref="F:Lokad.Rules.RuleLevel.None" /></summary>
      <param name="level">The level.</param>
      <returns>true if the condition is met</returns>
    </member>
    <member name="M:Lokad.Rules.Scope.WhenWarn(Lokad.Rules.RuleLevel)">
      <summary>
            Returns true if <paramref name="ruleLevel" />
            is <see cref="F:Lokad.Rules.RuleLevel.Warn" /> or higher
            </summary>
      <param name="ruleLevel">The rule level.</param>
      <returns>true if the condition is met</returns>
    </member>
    <member name="M:Lokad.Rules.Scope.WhenNone(Lokad.Rules.RuleLevel)">
      <summary>
            Returns true if <paramref name="ruleLevel" />
            is <see cref="F:Lokad.Rules.RuleLevel.None" /> or higher
            </summary>
      <param name="ruleLevel">The rule level.</param>
      <returns>true if the condition is met</returns>
    </member>
    <member name="M:Lokad.Rules.Scope.ForValidation(System.String,System.Predicate{Lokad.Rules.RuleLevel})">
      <summary>
            Creates scope that runs full check and then fails with 
            <see cref="T:Lokad.Rules.RuleException" />, if the resulting 
            <see cref="T:Lokad.Rules.RuleLevel" />  matches the <paramref name="predicate" /></summary>
      <param name="name">The name for the scope.</param>
      <param name="predicate">The predicate.</param>
      <returns>new scope instance</returns>
    </member>
    <member name="M:Lokad.Rules.Scope.ForEnforce(System.String,System.Predicate{Lokad.Rules.RuleLevel})">
      <summary>
            Creates scope that throws <see cref="T:Lokad.Rules.RuleException" /> as soon as
            first message matching <paramref name="predicate" /> is received.
            </summary>
      <param name="scopeName">Name of the scope.</param>
      <param name="predicate">The predicate.</param>
      <returns>new scope instance</returns>
    </member>
    <member name="M:Lokad.Rules.Scope.ForEnforceArgument(System.String,System.Predicate{Lokad.Rules.RuleLevel})">
      <summary>
            Creates scope that throws <see cref="T:System.ArgumentException" /> as soon as
            first message matching <paramref name="predicate" /> is received.
            </summary>
      <param name="scopeName">Name of the scope.</param>
      <param name="predicate">The predicate.</param>
      <returns>new scope instance</returns>
    </member>
    <member name="M:Lokad.Rules.Scope.IsError``1(``0,Lokad.Rules.Rule{``0}[])">
      <summary>  Determines whether the specified item has problems of 
            <see cref="F:Lokad.Rules.RuleLevel.Error" /> or higher.  </summary>
      <typeparam name="TItem">type of the item to run rules against</typeparam>
      <param name="item">The item to run rules against.</param>
      <param name="rules">The rules to execute.</param>
      <returns>
        <c>true</c> if the specified item is in error state; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.Rules.Scope.IsValid``1(``0,Lokad.Rules.Rule{``0}[])">
      <summary>  Determines whether the specified item does not have any problems </summary>
      <typeparam name="TItem">type of the item to run rules against</typeparam>
      <param name="item">The item to run rules against.</param>
      <param name="rules">The rules to execute.</param>
      <returns>
        <c>true</c> if the specified item is in error state; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.Rules.Scope.IsWarn``1(``0,Lokad.Rules.Rule{``0}[])">
      <summary>  Determines whether the specified item has problems of 
            <see cref="F:Lokad.Rules.RuleLevel.Warn" /> or higher.  </summary>
      <typeparam name="TItem">type of the item to run rules against</typeparam>
      <param name="item">The item to run rules against.</param>
      <param name="rules">The rules to execute.</param>
      <returns>
        <c>true</c> if the specified item is in warning state; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.Rules.Scope.GetMessages``1(``0,System.String,Lokad.Rules.Rule{``0}[])">
      <summary> Collects all rule messages associated with the 
            specified <paramref name="item" /></summary>
      <typeparam name="TItem">The type of the item to run the rules against.</typeparam>
      <param name="item">The item to run the rules against.</param>
      <param name="name">The name of the scope.</param>
      <param name="rules">The rules to execute.</param>
      <returns>read-only collection of <see cref="T:Lokad.Rules.RuleMessage" /></returns>
    </member>
    <member name="M:Lokad.Rules.Scope.GetMessages(System.String,System.Action{Lokad.Rules.IScope})">
      <summary>
            Gets the messages created by action being executed against the scope.
            </summary>
      <param name="name">The name for the scope.</param>
      <param name="scopeAction">The scope action.</param>
      <returns>read-only collection of <see cref="T:Lokad.Rules.RuleMessage" /></returns>
    </member>
    <member name="M:Lokad.Rules.Scope.GetMessages``1(System.Func{``0},Lokad.Rules.Rule{``0}[])">
      <summary>
            Collects all rule messages associated with the
            specified <paramref name="itemReference" /></summary>
      <typeparam name="TItem">The type of the item to run the rules against.</typeparam>
      <param name="itemReference">The item reference.</param>
      <param name="rules">The rules to execute.</param>
      <returns>
            read-only collection of <see cref="T:Lokad.Rules.RuleMessage" /></returns>
    </member>
    <member name="M:Lokad.Rules.Scope.GetMessagesForMany``1(System.Func{System.Collections.Generic.IEnumerable{``0}},Lokad.Rules.Rule{``0}[])">
      <summary>
            Collects all rule messages associated with the
            specified <paramref name="sequenceReference" /></summary>
      <typeparam name="TItem">The type of the item to run the rules against.</typeparam>
      <param name="sequenceReference">The sequence reference.</param>
      <param name="rules">The rules to execute.</param>
      <returns> read-only collection of <see cref="T:Lokad.Rules.RuleMessage" /></returns>
    </member>
    <member name="M:Lokad.Rules.Scope.GetMessagesForMany``1(System.Collections.Generic.IEnumerable{``0},System.String,Lokad.Rules.Rule{``0}[])">
      <summary> Collects all rule messages associated with the 
            specified <paramref name="items" /></summary>
      <typeparam name="TItem">The type of the item to run the rules against.</typeparam>
      <param name="items">The item to run the rules against.</param>
      <param name="name">The name of the scope.</param>
      <param name="rules">The rules to execute.</param>
      <returns>read-only collection of <see cref="T:Lokad.Rules.RuleMessage" /></returns>
    </member>
    <member name="M:Lokad.Rules.Scope.Validate``1(``0,Lokad.Rules.Rule{``0}[])">
      <summary>
            Runs full validation scan of the specified item and throws error
            if the level is not <see cref="F:Lokad.Rules.RuleLevel.None" /></summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="item">The item to validate.</param>
      <param name="rules">The rules.</param>
      <exception cref="T:Lokad.Rules.RuleException">if any rules have failed</exception>
    </member>
    <member name="M:Lokad.Rules.Scope.ValidateMany``1(System.Collections.Generic.IEnumerable{``0},Lokad.Rules.Rule{``0}[])">
      <summary>
            Runs full validation scan of the specified collection
            </summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="items">The collection to validate.</param>
      <param name="rules">The validators.</param>
      <exception cref="T:Lokad.Rules.RuleException">if any rules have failed</exception>
    </member>
    <member name="M:Lokad.Rules.Scope.ComposePath(System.String,System.String)">
      <summary>
            Composes the path for the <see cref="T:Lokad.Rules.Rule`1" />.
            </summary>
      <param name="prefix">The prefix.</param>
      <param name="suffix">The suffix.</param>
      <returns>composed path</returns>
      <exception cref="T:System.ArgumentException">if path parameters are null or empty</exception>
    </member>
    <member name="T:Lokad.Rules.IScopeExtensions">
      <summary> /// <para>Extensions that encapsulate some repetitive tasks
             of setting scopes, and calling validation rules.</para><para>Basically that's the class that links together scope 
             and validation logics.</para></summary>
    </member>
    <member name="M:Lokad.Rules.IScopeExtensions.Error(Lokad.Rules.IScope,System.String,System.Object[])">
      <summary> Outputs formatted <see cref="F:Lokad.Rules.RuleLevel.Error" /> 
            message into the  <paramref name="scope" /> using the 
            <see cref="P:System.Globalization.CultureInfo.InvariantCulture" /></summary>
      <param name="scope">The scope.</param>
      <param name="message">The message (see <see cref="M:System.String.Format(System.String,System.Object)" />).</param>
      <param name="args">The arguments.</param>
    </member>
    <member name="M:Lokad.Rules.IScopeExtensions.Error(Lokad.Rules.IScope,System.String)">
      <summary> Outputs <see cref="F:Lokad.Rules.RuleLevel.Error" /> 
            message into the  <paramref name="scope" /></summary>
      <param name="scope">The scope.</param>
      <param name="message">The message.</param>
    </member>
    <member name="M:Lokad.Rules.IScopeExtensions.Warn(Lokad.Rules.IScope,System.String,System.Object[])">
      <summary> Outputs formatted <see cref="F:Lokad.Rules.RuleLevel.Warn" /> 
            message into the  <paramref name="scope" /> using the 
            <see cref="P:System.Globalization.CultureInfo.InvariantCulture" /></summary>
      <param name="scope">The scope.</param>
      <param name="message">The message (see <see cref="M:System.String.Format(System.String,System.Object)" />).</param>
      <param name="args">The arguments.</param>
    </member>
    <member name="M:Lokad.Rules.IScopeExtensions.Warn(Lokad.Rules.IScope,System.String)">
      <summary> Outputs <see cref="F:Lokad.Rules.RuleLevel.Warn" /> 
            message into the  <paramref name="scope" /></summary>
      <param name="scope">The scope.</param>
      <param name="message">The message.</param>
    </member>
    <member name="M:Lokad.Rules.IScopeExtensions.Info(Lokad.Rules.IScope,System.String,System.Object[])">
      <summary> Outputs formatted <see cref="F:Lokad.Rules.RuleLevel.None" /> 
            message into the  <paramref name="scope" /> using the 
            <see cref="P:System.Globalization.CultureInfo.InvariantCulture" /></summary>
      <param name="scope">The scope.</param>
      <param name="message">The message (see <see cref="M:System.String.Format(System.String,System.Object)" />).</param>
      <param name="args">The arguments.</param>
    </member>
    <member name="M:Lokad.Rules.IScopeExtensions.Info(Lokad.Rules.IScope,System.String)">
      <summary> Outputs <see cref="F:Lokad.Rules.RuleLevel.None" /> 
            message into the  <paramref name="scope" /></summary>
      <param name="scope">The scope.</param>
      <param name="message">The message.</param>
    </member>
    <member name="M:Lokad.Rules.IScopeExtensions.IsError(Lokad.Rules.IScope)">
      <summary> Determines whether the specified <paramref name="scope" />
            is in the <see cref="F:Lokad.Rules.RuleLevel.Error" /> state. </summary>
      <param name="scope">The scope.</param>
      <returns>
        <c>true</c> if the specified scope is in <see cref="F:Lokad.Rules.RuleLevel.Error" /> 
            state; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.Rules.IScopeExtensions.IsNone(Lokad.Rules.IScope)">
      <summary> Determines whether the specified <paramref name="scope" />
            is in the <see cref="F:Lokad.Rules.RuleLevel.None" /> state. </summary>
      <param name="scope">The scope.</param>
      <returns>
        <c>true</c> if the specified scope is in <see cref="F:Lokad.Rules.RuleLevel.None" /> 
            state; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.Rules.IScopeExtensions.IsWarn(Lokad.Rules.IScope)">
      <summary> Determines whether the specified <paramref name="scope" />
            is in the <see cref="F:Lokad.Rules.RuleLevel.Warn" /> state. </summary>
      <param name="scope">The scope.</param>
      <returns>
        <c>true</c> if the specified scope is in <see cref="F:Lokad.Rules.RuleLevel.Warn" /> 
            state; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.Rules.IScopeExtensions.Validate``1(Lokad.INamedProvider{Lokad.Rules.IScope},``0,System.String,Lokad.Rules.Rule{``0}[])">
      <summary>
            Validates some member using the <paramref name="scopeProvider" />.
            </summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="scopeProvider">The scope provider.</param>
      <param name="item">The item to validate.</param>
      <param name="name">The name of the variable that holds item to validate.</param>
      <param name="rules">The rules to run.</param>
    </member>
    <member name="M:Lokad.Rules.IScopeExtensions.Validate``1(Lokad.Rules.IScope,``0,System.String,Lokad.Rules.Rule{``0}[])">
      <summary> Validates some member using the provided <paramref name="parentScope" />.
            </summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="parentScope">The parent scope.</param>
      <param name="item">The item to validate.</param>
      <param name="name">The name of the variable that holds item to validate.</param>
      <param name="rules">The rules to run.</param>
    </member>
    <member name="M:Lokad.Rules.IScopeExtensions.Validate``1(Lokad.Rules.IScope,System.Func{``0},Lokad.Rules.Rule{``0}[])">
      <summary>
            Validates some member using the provided <paramref name="parentScope" />.
            </summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="parentScope">The parent scope.</param>
      <param name="property">The property reference.</param>
      <param name="rules">The rules to run.</param>
    </member>
    <member name="M:Lokad.Rules.IScopeExtensions.ValidateMany``1(Lokad.Rules.IScope,System.Func{System.Collections.Generic.IEnumerable{``0}},Lokad.Rules.Rule{``0}[])">
      <summary>
            Validates some <see cref="T:System.Collections.Generic.IEnumerable`1" /> member using the provided <paramref name="parentScope" />.
            </summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="parentScope">The parent scope.</param>
      <param name="propertyReference">Reference to collection property to validate.</param>
      <param name="rules">The rules to run.</param>
    </member>
    <member name="M:Lokad.Rules.IScopeExtensions.ValidateMany``1(Lokad.Rules.IScope,System.Collections.Generic.IEnumerable{``0},System.String,Lokad.Rules.Rule{``0}[])">
      <summary>
            Validates some <see cref="T:System.Collections.Generic.IEnumerable`1" /> member using the provided <paramref name="parentScope" />.
            </summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="parentScope">The parent scope.</param>
      <param name="items">The collection to validate.</param>
      <param name="name">The name of the variable that holds item to validate.</param>
      <param name="rules">The rules to run.</param>
    </member>
    <member name="M:Lokad.Rules.IScopeExtensions.ValidateMany``1(Lokad.Rules.IScope,System.Collections.Generic.ICollection{``0},System.String,System.Int32,Lokad.Rules.Rule{``0}[])">
      <summary>
            Validates some <see cref="T:System.Collections.Generic.IEnumerable`1" /> member using the provided <paramref name="parentScope" />.
            </summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="parentScope">The parent scope.</param>
      <param name="items">The collection to validate.</param>
      <param name="name">The name of the variable that holds item to validate.</param>
      <param name="limit">The limit (if collection is bigger, then validation will not continue).</param>
      <param name="rules">The rules to run.</param>
    </member>
    <member name="M:Lokad.Rules.IScopeExtensions.ValidateInScope``1(Lokad.Rules.IScope,``0,Lokad.Rules.Rule{``0}[])">
      <summary>
            Runs the specified rules against the provided object in the current scope
            </summary>
      <typeparam name="T">type of the object being validated</typeparam>
      <param name="scope">The scope.</param>
      <param name="item">The item to validate.</param>
      <param name="rules">The rules to execute.</param>
    </member>
    <member name="M:Lokad.Rules.IScopeExtensions.ValidateInScope``1(Lokad.Rules.IScope,System.Collections.Generic.IEnumerable{``0},Lokad.Rules.Rule{``0}[])">
      <summary>
            Runs validation rules against some some <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            </summary>
      <typeparam name="T">type of the items being validated</typeparam>
      <param name="parentScope">The parent scope.</param>
      <param name="items">Collection of the items to validate</param>
      <param name="rules">The rules to run.</param>
    </member>
    <member name="M:Lokad.Rules.IScopeExtensions.Lower(Lokad.Rules.IScope)">
      <summary>
            Creates a wrapper that lowers the importance of messages
            being passed to the specified <paramref name="scope" />.
            </summary>
      <param name="scope">The scope to wrap.</param>
      <returns>new instance of the wrapper</returns>
    </member>
    <member name="M:Lokad.Rules.IScopeExtensions.Raise(Lokad.Rules.IScope)">
      <summary>
            Creates a wrapper that boosts the <see cref="T:Lokad.Rules.RuleLevel" /> of
            messages being passed to the specified<paramref name="scope" />.
            </summary>
      <param name="scope">The scope to wrap.</param>
      <returns>new instance of the wrapper</returns>
    </member>
    <member name="T:Lokad.Rules.TrackScope">
      <summary>
        <see cref="T:Lokad.Rules.IScope" /> that merely keeps track of the worst level. 
            </summary>
    </member>
    <member name="T:Lokad.StringUtil">
      <summary>
            Helper methods for <see cref="T:System.String" /></summary>
    </member>
    <member name="M:Lokad.StringUtil.FormatInvariant(System.String,System.Object[])">
      <summary>
            Formats the string using InvariantCulture
            </summary>
      <param name="format">The format.</param>
      <param name="args">The args.</param>
      <returns>formatted string</returns>
    </member>
    <member name="M:Lokad.StringUtil.MemberNameToCaption(System.String)">
      <summary>
            Converts "Class.SomeName" to "Class - Some Name"
            </summary>
    </member>
    <member name="T:Lokad.Syntax">
      <summary>
            Helper class for creating fluent APIs, that hides unused signatures
            </summary>
    </member>
    <member name="M:Lokad.Syntax.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Lokad.Syntax.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
      <exception cref="T:System.NullReferenceException">
            The <paramref name="obj" /> parameter is null.
            </exception>
    </member>
    <member name="M:Lokad.Syntax.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Lokad.Syntax.GetType">
      <summary>
            Gets the <see cref="T:System.Type" /> of the current instance.
            </summary>
      <returns>
            The <see cref="T:System.Type" /> instance that represents the exact runtime type of the current instance.
            </returns>
    </member>
    <member name="M:Lokad.Syntax.For``1(``0)">
      <summary>
            Creates the syntax for the specified target
            </summary>
      <typeparam name="TTarget">The type of the target.</typeparam>
      <param name="inner">The inner.</param>
      <returns>new syntax instance</returns>
    </member>
    <member name="T:Lokad.Syntax`1">
      <summary>
            Helper class for creating fluent APIs
            </summary>
      <typeparam name="T">underlying type</typeparam>
    </member>
    <member name="M:Lokad.Syntax`1.#ctor(`0)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Syntax`1" /> class.
            </summary>
      <param name="inner">The underlying instance.</param>
    </member>
    <member name="P:Lokad.Syntax`1.Target">
      <summary>
            Gets the underlying object.
            </summary>
      <value>The underlying object.</value>
    </member>
    <member name="T:Lokad.Threading.ReaderWriterLockSlimExtensions">
      <summary>
            Helper class that simplifies <see cref="T:System.Threading.ReaderWriterLockSlim" /> usage
            </summary>
    </member>
    <member name="M:Lokad.Threading.ReaderWriterLockSlimExtensions.GetReadLock(System.Threading.ReaderWriterLockSlim)">
      <summary>
            Gets the read lock object, that is released when the object is disposed.
            </summary>
      <param name="slimLock">The slim lock object.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Lokad.Threading.ReaderWriterLockSlimExtensions.GetWriteLock(System.Threading.ReaderWriterLockSlim)">
      <summary>
            Gets the write lock, that is released when the object is disposed.
            </summary>
      <param name="slimLock">The slim lock.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Lokad.Threading.ReaderWriterLockSlimExtensions.GetUpgradeableReadLock(System.Threading.ReaderWriterLockSlim)">
      <summary>
            Gets the upgradeable read lock, that is released, when the object is disposed
            </summary>
      <param name="slimLock">The slim lock.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Lokad.Tuple`2">
      <summary>
            Tuple class with 2 items
            </summary>
      <typeparam name="T1">The type of the first item.</typeparam>
      <typeparam name="T2">The type of the second item.</typeparam>
    </member>
    <member name="M:Lokad.Tuple`2.#ctor(`0,`1)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Pair`2" /> class.
            </summary>
      <param name="first">The first item.</param>
      <param name="second">The second item.</param>
    </member>
    <member name="M:Lokad.Tuple`2.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:Lokad.Pair`2" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:Lokad.Pair`2" />.</param>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:Lokad.Pair`2" />; otherwise, false.
            </returns>
      <exception cref="T:System.NullReferenceException">
            The <paramref name="obj" /> parameter is null.
            </exception>
    </member>
    <member name="M:Lokad.Tuple`2.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:Lokad.Pair`2" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:Lokad.Pair`2" />.
            </returns>
    </member>
    <member name="M:Lokad.Tuple`2.Equals(Lokad.Tuple{`0,`1})">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <returns>
            true if the current object is equal to the <paramref name="obj" /> parameter; otherwise, false.
            </returns>
      <param name="obj">
            An object to compare with this object.
            </param>
    </member>
    <member name="M:Lokad.Tuple`2.GetHashCode">
      <summary>
            Serves as a hash function for a particular type. 
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:Lokad.Tuple`2.op_Equality(Lokad.Tuple{`0,`1},Lokad.Tuple{`0,`1})">
      <summary>
            Implements the operator ==.
            </summary>
      <param name="left">The left.</param>
      <param name="right">The right.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Lokad.Tuple`2.op_Inequality(Lokad.Tuple{`0,`1},Lokad.Tuple{`0,`1})">
      <summary>
            Implements the operator !=.
            </summary>
      <param name="left">The left.</param>
      <param name="right">The right.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="P:Lokad.Tuple`2.Item1">
      <summary>
            Gets Item1.
            </summary>
      <value>The item1.</value>
    </member>
    <member name="P:Lokad.Tuple`2.Item2">
      <summary>
            Gets Item2.
            </summary>
      <value>The item2.</value>
    </member>
    <member name="T:Lokad.Pair`2">
      <summary>
            Tuple class with 2 items
            </summary>
      <typeparam name="TKey">The type of the first item.</typeparam>
      <typeparam name="TValue">The type of the second item.</typeparam>
    </member>
    <member name="M:Lokad.Pair`2.#ctor(`0,`1)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Pair`2" /> class.
            </summary>
      <param name="first">The first item.</param>
      <param name="second">The second item.</param>
    </member>
    <member name="P:Lokad.Pair`2.Key">
      <summary>
            Gets the key (or Item1).
            </summary>
      <value>The key.</value>
    </member>
    <member name="P:Lokad.Pair`2.Value">
      <summary>
            Gets the value (or Item2).
            </summary>
      <value>The value.</value>
    </member>
    <member name="T:Lokad.Reflection.Reflect">
      <summary>
            Helper class for the IL-based strongly-typed reflection
            </summary>
      <remarks>This class is not supported by Silverlight 2.0, yet</remarks>
    </member>
    <member name="M:Lokad.Reflection.Reflect.Variable``1(System.Func{``0})">
      <summary>
            Retrieves via IL the information of the <b>local</b> variable passed in the expression.
            <code>
            var myVar = "string";
            var info = Reflect.Variable(() =&gt; myVar)
            </code></summary>
      <typeparam name="T">
      </typeparam>
      <param name="expression">The expression containing the local variable to reflect.</param>
      <returns>information about the variable</returns>
    </member>
    <member name="M:Lokad.Reflection.Reflect.Property``1(System.Func{``0})">
      <summary>
            Retrieves via IL the <em>getter method</em> for the property being reflected.
            <code>
            var i2 = new
            {
              MyProperty = "Value"
            }; 
            var info = Reflect.Property(() =&gt; i2.Property);
            // info will have name of "get_MyProperty"
            </code></summary>
      <typeparam name="T">type of the property to reflect</typeparam>
      <param name="expression">The expression.</param>
      <returns>getter method for the property.</returns>
    </member>
    <member name="T:Lokad.Tuple`3">
      <summary>
            Tuple class with 3 items
            </summary>
      <typeparam name="T1">The type of the first item.</typeparam>
      <typeparam name="T2">The type of the second item.</typeparam>
      <typeparam name="T3">The type of the third item.</typeparam>
    </member>
    <member name="M:Lokad.Tuple`3.#ctor(`0,`1,`2)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Triple`3" /> class.
            </summary>
      <param name="first">The first item.</param>
      <param name="second">The second item.</param>
      <param name="third">The third item.</param>
    </member>
    <member name="M:Lokad.Tuple`3.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:Lokad.Triple`3" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:Lokad.Triple`3" />.
            </returns>
    </member>
    <member name="M:Lokad.Tuple`3.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:Lokad.Triple`3" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:Lokad.Triple`3" />.</param>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:Lokad.Triple`3" />; otherwise, false.
            </returns>
      <exception cref="T:System.NullReferenceException">
            The <paramref name="obj" /> parameter is null.
            </exception>
    </member>
    <member name="M:Lokad.Tuple`3.Equals(Lokad.Tuple{`0,`1,`2})">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <returns>
            true if the current object is equal to the <paramref name="obj" /> parameter; otherwise, false.
            </returns>
      <param name="obj">
            An object to compare with this object.
            </param>
    </member>
    <member name="M:Lokad.Tuple`3.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>
            A hash code for the current <see cref="T:Lokad.Triple`3" />.
            </returns>
    </member>
    <member name="M:Lokad.Tuple`3.op_Equality(Lokad.Tuple{`0,`1,`2},Lokad.Tuple{`0,`1,`2})">
      <summary>
            Implements the operator ==.
            </summary>
      <param name="left">The left.</param>
      <param name="right">The right.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Lokad.Tuple`3.op_Inequality(Lokad.Tuple{`0,`1,`2},Lokad.Tuple{`0,`1,`2})">
      <summary>
            Implements the operator !=.
            </summary>
      <param name="left">The left.</param>
      <param name="right">The right.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="P:Lokad.Tuple`3.Item1">
      <summary>
            Gets Item1.
            </summary>
      <value>The item1.</value>
    </member>
    <member name="P:Lokad.Tuple`3.Item2">
      <summary>
            Gets Item2.
            </summary>
      <value>The item2.</value>
    </member>
    <member name="P:Lokad.Tuple`3.Item3">
      <summary>
            Gets Item3.
            </summary>
      <value>The item3.</value>
    </member>
    <member name="T:Lokad.Triple`3">
      <summary>
            Tuple class with 3 items
            </summary>
      <typeparam name="T1">The type of the first item.</typeparam>
      <typeparam name="T2">The type of the second item.</typeparam>
      <typeparam name="T3">The type of the third item.</typeparam>
    </member>
    <member name="M:Lokad.Triple`3.#ctor(`0,`1,`2)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Triple`3" /> class.
            </summary>
      <param name="first">The first item.</param>
      <param name="second">The second item.</param>
      <param name="third">The third item.</param>
    </member>
    <member name="T:Lokad.Tuple">
      <summary>
            Helper class that simplifies tuple inline generation
            </summary>
      <example>
            Tuple.From("Mike",1,true)
            </example>
    </member>
    <member name="M:Lokad.Tuple.From``2(``0,``1)">
      <summary>
            Creates <see cref="T:Lokad.Pair`2" /> out of two arguments
            </summary>
      <typeparam name="T1">The type of the first item.</typeparam>
      <typeparam name="T2">The type of the second item.</typeparam>
      <param name="first">The first item.</param>
      <param name="second">The second item.</param>
      <returns>New tuple instance</returns>
    </member>
    <member name="M:Lokad.Tuple.From``3(``0,``1,``2)">
      <summary>
            Creates <see cref="T:Lokad.Triple`3" /> out of the three arguments
            </summary>
      <typeparam name="T1">The type of the first item.</typeparam>
      <typeparam name="T2">The type of the second item.</typeparam>
      <typeparam name="T3">The type of the third item.</typeparam>
      <param name="first">The first item.</param>
      <param name="second">The second item.</param>
      <param name="third">The third item.</param>
      <returns>New tuple instance</returns>
    </member>
    <member name="M:Lokad.Tuple.From``4(``0,``1,``2,``3)">
      <summary>
            Creates <see cref="T:Lokad.Tuple`4" /> out of four arguments
            </summary>
      <typeparam name="T1">The type of the first item.</typeparam>
      <typeparam name="T2">The type of the second item.</typeparam>
      <typeparam name="T3">The type of the third item.</typeparam>
      <typeparam name="T4">The type of the fourth.</typeparam>
      <param name="first">The first item.</param>
      <param name="second">The second item.</param>
      <param name="third">The third item.</param>
      <param name="fourth">The fourth item.</param>
      <returns>New instance</returns>
    </member>
    <member name="M:Lokad.Tuple.From``5(``0,``1,``2,``3,``4)">
      <summary>
            Creates <see cref="T:Lokad.Tuple`4" /> out of four arguments
            </summary>
      <typeparam name="T1">The type of the first item.</typeparam>
      <typeparam name="T2">The type of the second item.</typeparam>
      <typeparam name="T3">The type of the third item.</typeparam>
      <typeparam name="T4">The type of the fourth item.</typeparam>
      <typeparam name="T5">The type of the fifth item.</typeparam>
      <param name="first">The first item.</param>
      <param name="second">The second item.</param>
      <param name="third">The third item.</param>
      <param name="fourth">The fourth item.</param>
      <param name="fifth">The fifth item.</param>
      <returns>New instance</returns>
    </member>
    <member name="T:Lokad.Tuple`5">
      <summary>
            Tuple class with 5 items (also called <em>Quintuple</em>)
            </summary>
      <typeparam name="T1">The type of the first item.</typeparam>
      <typeparam name="T2">The type of the second item.</typeparam>
      <typeparam name="T3">The type of the third item.</typeparam>
      <typeparam name="T4">The type of the fourth item.</typeparam>
      <typeparam name="T5">The type of the fifthi item.</typeparam>
    </member>
    <member name="M:Lokad.Tuple`5.#ctor(`0,`1,`2,`3,`4)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Tuple`4" /> class.
            </summary>
      <param name="first">The first item.</param>
      <param name="second">The second item.</param>
      <param name="third">The third item.</param>
      <param name="fourth">The fourth item.</param>
      <param name="fifth">The fifth item.</param>
    </member>
    <member name="M:Lokad.Tuple`5.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:Lokad.Tuple`5" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:Lokad.Tuple`5" />.
            </returns>
    </member>
    <member name="M:Lokad.Tuple`5.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:Lokad.Tuple`5" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:Lokad.Tuple`5" />.</param>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:Lokad.Tuple`5" />; otherwise, false.
            </returns>
      <exception cref="T:System.NullReferenceException">
            The <paramref name="obj" /> parameter is null.
            </exception>
    </member>
    <member name="M:Lokad.Tuple`5.Equals(Lokad.Tuple{`0,`1,`2,`3,`4})">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <returns>
            true if the current object is equal to the <paramref name="obj" /> parameter; otherwise, false.
            </returns>
      <param name="obj">
            An object to compare with this object.
            </param>
    </member>
    <member name="M:Lokad.Tuple`5.GetHashCode">
      <summary>
            Serves as a hash function for a particular type. 
            </summary>
      <returns>
            A hash code for the current <see cref="T:Lokad.Tuple`5" />.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:Lokad.Tuple`5.op_Equality(Lokad.Tuple{`0,`1,`2,`3,`4},Lokad.Tuple{`0,`1,`2,`3,`4})">
      <summary>
            Implements the operator ==.
            </summary>
      <param name="left">The left.</param>
      <param name="right">The right.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Lokad.Tuple`5.op_Inequality(Lokad.Tuple{`0,`1,`2,`3,`4},Lokad.Tuple{`0,`1,`2,`3,`4})">
      <summary>
            Implements the operator !=.
            </summary>
      <param name="left">The left.</param>
      <param name="right">The right.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="P:Lokad.Tuple`5.Item1">
      <summary>
            Gets or sets the item1.
            </summary>
      <value>The item1.</value>
    </member>
    <member name="P:Lokad.Tuple`5.Item2">
      <summary>
            Gets or sets the item2.
            </summary>
      <value>The item2.</value>
    </member>
    <member name="P:Lokad.Tuple`5.Item3">
      <summary>
            Gets or sets the item3.
            </summary>
      <value>The item3.</value>
    </member>
    <member name="P:Lokad.Tuple`5.Item4">
      <summary>
            Gets or sets the item4.
            </summary>
      <value>The item4.</value>
    </member>
    <member name="P:Lokad.Tuple`5.Item5">
      <summary>
            Gets or sets the item5.
            </summary>
      <value>The item5.</value>
    </member>
    <member name="T:Lokad.TypeExtensions">
      <summary>
            Helper related to the <see cref="T:System.Type" /></summary>
    </member>
    <member name="M:Lokad.TypeExtensions.GetAttributes``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
      <summary>
             Extension method to retrieve attributes from the type
            </summary>
      <param name="target">Type to perform operation upon</param>
      <param name="inherit">
        <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />
      </param>
      <typeparam name="T">Attribute to use</typeparam>
      <returns>Empty array of <typeparamref name="T" /> if there are no attributes</returns>
    </member>
    <member name="M:Lokad.TypeExtensions.GetAttribute``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
      <summary>
             Returns single attribute from the type
             </summary>
      <typeparam name="T">Attribute to use</typeparam>
      <param name="target">Attribute provider</param>
      <param name="inherit">
        <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />
      </param>
      <returns>
        <em>Null</em> if the attribute is not found</returns>
      <exception cref="T:System.InvalidOperationException">If there are 2 or more attributes</exception>
    </member>
    <member name="M:Lokad.TypeExtensions.MarkedWith``1(System.Collections.Generic.IEnumerable{System.Type},System.Boolean)">
      <summary>
            Selects non-abstract types marked with the specified attribute
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="types">
      </param>
      <param name="inherit">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Lokad.Diagnostics.ExecutionCounterGroup">
      <summary>
            Helper class to simplify counter creation syntax
            </summary>
    </member>
    <member name="M:Lokad.Diagnostics.ExecutionCounterGroup.Register">
      <summary>
            Registers the counters in the global cache
            </summary>
    </member>
    <member name="M:Lokad.Diagnostics.ExecutionCounterGroup.CreateCounter(System.String,System.Int32,System.Int32)">
      <summary>
            Creates the counter and adds it to the internal collection.
            </summary>
      <param name="name">The name for the new counter.</param>
      <param name="openCounterCount">The open counter count.</param>
      <param name="closeCounterCount">The close counter count.</param>
      <returns>instance of the created counter</returns>
    </member>
    <member name="M:Lokad.Diagnostics.ExecutionCounterGroup.CreateCounter(System.Linq.Expressions.Expression{System.Action},System.Int32,System.Int32)">
      <summary> Creates the counter and adds it to the internal collection. </summary>
      <param name="expression">The expression to derive counter name from.</param>
      <param name="openCounterCount">The open counter count.</param>
      <param name="closeCounterCount">The close counter count.</param>
      <returns>instance of the new counter</returns>
    </member>
    <member name="M:Lokad.Diagnostics.ExecutionCounterGroup.CreateCounterForCtor``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Int32,System.Int32)">
      <summary> Creates the counter and adds it to the internal collection. </summary>
      <param name="expression">The expression to derive counter name from.</param>
      <param name="openCounterCount">The open counter count.</param>
      <param name="closeCounterCount">The close counter count.</param>
      <returns>instance of the new counter</returns>
    </member>
    <member name="T:Lokad.Diagnostics.ExecutionCounterGroup`1">
      <summary>
            Helper class to simplify counter creation syntax
            </summary>
    </member>
    <member name="M:Lokad.Diagnostics.ExecutionCounterGroup`1.CreateCounter(System.Linq.Expressions.Expression{System.Action{`0}},System.Int32,System.Int32)">
      <summary>
            Creates new counter and adds it to the internal collection
            </summary>
      <param name="call">The call to derive counter name from.</param>
      <param name="openCounterCount">The open counter count.</param>
      <param name="closeCounterCount">The close counter count.</param>
      <returns>instance of the created counter</returns>
    </member>
    <member name="T:Lokad.Diagnostics.ExceptionCounters">
      <summary>
            Exception counter that persists unique information about exceptions being entered in an internal dictionary. 
            Once it gets filled, exceptions with the least number of occurences are discarded.
            </summary>
      <remarks>The class <see cref="T:Lokad.Diagnostics.ExceptionCounters" /> is designed as <strong>thread-safe</strong>.</remarks>
    </member>
    <member name="F:Lokad.Diagnostics.ExceptionCounters.DefaultCapacity">
      <summary>
            Default capacity for the <see cref="T:Lokad.Diagnostics.ExceptionCounters" /></summary>
    </member>
    <member name="F:Lokad.Diagnostics.ExceptionCounters.Default">
      <summary>
            Singleton instance of this counter
            </summary>
    </member>
    <member name="M:Lokad.Diagnostics.ExceptionCounters.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Diagnostics.ExceptionCounters" /> class.
            </summary>
      <param name="exceptionThreshold">Maximum number of unique exceptions to keep at once.</param>
    </member>
    <member name="M:Lokad.Diagnostics.ExceptionCounters.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Diagnostics.ExceptionCounters" /> class with the <see cref="F:Lokad.Diagnostics.ExceptionCounters.DefaultCapacity" />.
            </summary>
    </member>
    <member name="M:Lokad.Diagnostics.ExceptionCounters.Add(System.Exception)">
      <summary>
            Registers the provided exception in this counter
            </summary>
      <param name="ex">The exception to register</param>
      <returns>
      </returns>
      <rereturns>unique identifier for the exception</rereturns>
    </member>
    <member name="M:Lokad.Diagnostics.ExceptionCounters.GetHistory">
      <summary>
            Returns the list of all exceptions 
            </summary>
      <returns>list of <see cref="T:Lokad.Diagnostics.ExceptionCounter" /></returns>
    </member>
    <member name="M:Lokad.Diagnostics.ExceptionCounters.Clear">
      <summary>
            Clears this counter.
            </summary>
    </member>
    <member name="P:Lokad.Diagnostics.ExceptionCounters.CapacityThreshold">
      <summary>
            Gets or sets the number of exceptions this list can store.
            </summary>
      <value>The capacity.</value>
    </member>
    <member name="T:Lokad.Diagnostics.SystemDescriptor">
      <summary>
            Represents information about any subsystem
            (to be used in monitoring and reports)
            </summary>
    </member>
    <member name="M:Lokad.Diagnostics.SystemDescriptor.#ctor(System.String,System.Version,System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Diagnostics.SystemDescriptor" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="version">The version.</param>
      <param name="configuration">The configuration.</param>
      <param name="instance">The instance.</param>
    </member>
    <member name="M:Lokad.Diagnostics.SystemDescriptor.#ctor(System.Reflection.Assembly)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Diagnostics.SystemDescriptor" /> class.
            </summary>
      <param name="assembly">The assembly to derive configuration from.</param>
    </member>
    <member name="M:Lokad.Diagnostics.SystemDescriptor.InitializeDefault(Lokad.Diagnostics.SystemDescriptor)">
      <summary>
            Initializes the <see cref="P:Lokad.Diagnostics.SystemDescriptor.Default" /> value with the provided <paramref name="descriptor" />.
            </summary>
      <param name="descriptor">The descriptor.</param>
    </member>
    <member name="M:Lokad.Diagnostics.SystemDescriptor.InitializeDefault">
      <summary>
            Initializes the <see cref="P:Lokad.Diagnostics.SystemDescriptor.Default" /> value with the 
            <see cref="T:Lokad.Diagnostics.SystemDescriptor" /> that derives its values from the calling
            assembly.
            </summary>
    </member>
    <member name="M:Lokad.Diagnostics.SystemDescriptor.ToString">
      <summary>
        <see cref="M:System.Object.ToString" />
      </summary>
    </member>
    <member name="P:Lokad.Diagnostics.SystemDescriptor.Version">
      <summary>
            Version of the system
            </summary>
    </member>
    <member name="P:Lokad.Diagnostics.SystemDescriptor.Name">
      <summary>
            Name of the system. I.e.: WebApp
            </summary>
    </member>
    <member name="P:Lokad.Diagnostics.SystemDescriptor.Configuration">
      <summary>
            Configuration of the system. I.e.: DEBUG
            </summary>
    </member>
    <member name="P:Lokad.Diagnostics.SystemDescriptor.Default">
      <summary>
            Gets the default descriptor for the current system.
            </summary>
      <value>The default descriptor.</value>
    </member>
    <member name="P:Lokad.Diagnostics.SystemDescriptor.Instance">
      <summary>
            Instance descriptor. I.e.: 127.0.0.1
            </summary>
    </member>
    <member name="T:Lokad.Enforce">
      <summary>
            Helper class allows to follow the principles defined by Microsoft P&amp;P team.
            </summary>
    </member>
    <member name="M:Lokad.Enforce.Argument``1(System.Func{``0})">
      <summary>
        <para>Throws exception if the provided object is null. </para>
        <code>Enforce.Argument(() =&gt; args);</code>
      </summary>
      <typeparam name="TValue">type of the class to check</typeparam>
      <param name="argumentReference">The argument reference to check.</param>
      <exception cref="T:System.ArgumentNullException">If the class reference is null.</exception>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
    </member>
    <member name="M:Lokad.Enforce.Arguments``2(System.Func{``0},System.Func{``1})">
      <summary>
        <para>Throws exception if one of the provided objects is null. </para>
        <code>Enforce.Arguments(() =&gt; controller, () =&gt; service);</code>
      </summary>
      <param name="first">The first argument to check for</param>
      <param name="second">The second argument to check for.</param>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
    </member>
    <member name="M:Lokad.Enforce.Arguments``3(System.Func{``0},System.Func{``1},System.Func{``2})">
      <summary>
        <para>Throws exception if one of the provided objects is null. </para>
        <code>Enforce.Arguments(() =&gt; controller, () =&gt; service, () =&gt; parameters);</code>
      </summary>
      <typeparam name="T1">The type of the first argument.</typeparam>
      <typeparam name="T2">The type of the second argument.</typeparam>
      <typeparam name="T3">The type of the third argument.</typeparam>
      <param name="first">The first argument to check</param>
      <param name="second">The second argument to check.</param>
      <param name="third">The third argument to check.</param>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
    </member>
    <member name="M:Lokad.Enforce.Arguments``4(System.Func{``0},System.Func{``1},System.Func{``2},System.Func{``3})">
      <summary>
        <para>Throws exception if one of the provided objects is null. </para>
        <code>Enforce.Arguments(() =&gt; controller, () =&gt; service, () =&gt; parameters);</code>
      </summary>
      <typeparam name="T1">The type of the first argument.</typeparam>
      <typeparam name="T2">The type of the second argument.</typeparam>
      <typeparam name="T3">The type of the third argument.</typeparam>
      <typeparam name="T4">The type of the fourth argument.</typeparam>
      <param name="first">The first argument to check.</param>
      <param name="second">The second argument to check.</param>
      <param name="third">The third argument to check.</param>
      <param name="fourth">The fourth argument to check.</param>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
    </member>
    <member name="M:Lokad.Enforce.Arguments``5(System.Func{``0},System.Func{``1},System.Func{``2},System.Func{``3},System.Func{``4})">
      <summary>
        <para>Throws exception if one of the provided objects is null. </para>
        <code>Enforce.Arguments(() =&gt; controller, () =&gt; service, () =&gt; parameters);</code>
      </summary>
      <typeparam name="T1">The type of the first argument.</typeparam>
      <typeparam name="T2">The type of the second argument.</typeparam>
      <typeparam name="T3">The type of the third argument.</typeparam>
      <typeparam name="T4">The type of the fourth argument.</typeparam>
      <typeparam name="T5">The type of the fifth argument.</typeparam>
      <param name="first">The first argument to check.</param>
      <param name="second">The second argument to check.</param>
      <param name="third">The third argument to check.</param>
      <param name="fourth">The fourth argument to check.</param>
      <param name="fifth">The fifth argument to check.</param>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
    </member>
    <member name="M:Lokad.Enforce.ArgumentNotEmpty(System.Func{System.String})">
      <summary>
            Throws proper exception if the provided string argument is null or empty. 
            </summary>
      <returns>Original string.</returns>
      <exception cref="T:System.ArgumentException">If the string argument is null or empty.</exception>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
    </member>
    <member name="M:Lokad.Enforce.That(System.Boolean,System.String)">
      <summary>
            Throws exception if the check does not pass.
            </summary>
      <exception cref="T:System.InvalidOperationException">If the assertion has failed.</exception>
    </member>
    <member name="M:Lokad.Enforce.That(System.Boolean)">
      <summary>
            Throws exception if the check does not pass.
            </summary>
      <exception cref="T:System.InvalidOperationException">If the assertion has failed.</exception>
    </member>
    <member name="M:Lokad.Enforce.With``1(System.Boolean,System.String,System.Object[])">
      <summary>
            Throws <typeparamref name="TException" /> if the <paramref name="check" />
            failes
            </summary>
      <typeparam name="TException">The type of the exception.</typeparam>
      <param name="check">Check that should be true.</param>
      <param name="message">The message.</param>
      <param name="args">String arguments.</param>
      <exception cref="T:System.Exception">of <typeparamref name="TException" /> type</exception>
    </member>
    <member name="M:Lokad.Enforce.Argument(System.Boolean,System.String,System.String)">
      <summary> Throws exception if the argument fails the <paramref name="check" /></summary>
      <param name="check">Throw exception if false.</param>
      <param name="paramName">Name of the param.</param>
      <param name="checkName">Name of the check.</param>
      <exception cref="T:System.ArgumentException">When the argument fails the check</exception>
    </member>
    <member name="M:Lokad.Enforce.NotNull``1(System.Func{``0})">
      <summary>
            Throws proper exception if the class reference is null.
            </summary>
      <typeparam name="TValue">
      </typeparam>
      <param name="value">Class reference to check.</param>
      <exception cref="T:System.InvalidOperationException">If class reference is null.</exception>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
    </member>
    <member name="M:Lokad.Enforce.ArgumentNotNull``1(``0,System.String)">
      <summary>
            Throws proper exception if the provided class reference is null.
            Can be used for inline checks.
            </summary>
      <typeparam name="TValue">Class type</typeparam>
      <param name="value">Class reference to check.</param>
      <param name="argumentName">Name of the argument.</param>
      <returns>Original reference.</returns>
      <exception cref="T:System.ArgumentNullException">If the class reference is null.</exception>
    </member>
    <member name="M:Lokad.Enforce.Argument``1(System.Func{``0},Lokad.Rules.Rule{``0}[])">
      <summary>
            Runs the rules against single argument, using scope that fails on <see cref="M:Lokad.Rules.Scope.WhenError(Lokad.Rules.RuleLevel)" /></summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="argumentReference">The argument reference.</param>
      <param name="rules">The rules.</param>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
      <exception cref="T:System.ArgumentException">When any rule fails</exception>
    </member>
    <member name="M:Lokad.Enforce.Argument``1(System.Func{System.Collections.Generic.IEnumerable{``0}},Lokad.Rules.Rule{``0}[])">
      <summary>
            Runs the rules against single collection, using scope that fails on <see cref="M:Lokad.Rules.Scope.WhenError(Lokad.Rules.RuleLevel)" /></summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="items">The items to validate.</param>
      <param name="rules">The rules.</param>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
      <exception cref="T:System.ArgumentException">When any rule fails</exception>
    </member>
    <member name="M:Lokad.Enforce.That``1(``0,Lokad.Rules.Rule{``0}[])">
      <summary> Runs the rules against single argument, 
            using scope that fails on <see cref="M:Lokad.Rules.Scope.WhenError(Lokad.Rules.RuleLevel)" />.
             </summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="item">The item to validate.</param>
      <param name="rules">The rules.</param>
      <exception cref="T:Lokad.Rules.RuleException">When check fails</exception>
    </member>
    <member name="M:Lokad.Enforce.That``1(System.Collections.Generic.IEnumerable{``0},Lokad.Rules.Rule{``0}[])">
      <summary> Runs the rules against single collection, using 
            scope that fails on <see cref="M:Lokad.Rules.Scope.WhenError(Lokad.Rules.RuleLevel)" />.</summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="items">The items to validate.</param>
      <param name="rules">The rules.</param>
      <exception cref="T:Lokad.Rules.RuleException">When check fails</exception>
    </member>
    <member name="M:Lokad.Enforce.That``1(System.Func{``0},Lokad.Rules.Rule{``0}[])">
      <summary> Runs the rules against single item, using 
            scope that fails on <see cref="M:Lokad.Rules.Scope.WhenError(Lokad.Rules.RuleLevel)" />.</summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="argumentReference">The item to validate.</param>
      <param name="rules">The rules.</param>
      <exception cref="T:Lokad.Rules.RuleException">When check fails</exception>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
    </member>
    <member name="M:Lokad.Enforce.That``1(System.Func{System.Collections.Generic.IEnumerable{``0}},Lokad.Rules.Rule{``0}[])">
      <summary> Runs the rules against collection, 
            using scope that fails on <see cref="M:Lokad.Rules.Scope.WhenError(Lokad.Rules.RuleLevel)" /></summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="collectionReference">The items to validate.</param>
      <param name="rules">The rules.</param>
      <exception cref="T:Lokad.Rules.RuleException">When check fails</exception>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
    </member>
    <member name="T:Lokad.ICollectionExtensions">
      <summary>
            Simple helper extensions for <see cref="T:System.Collections.Generic.ICollection`1" /></summary>
    </member>
    <member name="M:Lokad.ICollectionExtensions.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Adds all items to the target collection
            </summary>
      <typeparam name="T">type of the item within the collection</typeparam>
      <param name="collection">The collection</param>
      <param name="items">items to add to the collection</param>
      <returns>same collection instance</returns>
    </member>
    <member name="M:Lokad.ICollectionExtensions.RemoveRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Removes all items from the target collection
            </summary>
      <typeparam name="T">type of the item within the collection</typeparam>
      <param name="collection">The collection.</param>
      <param name="items">The items.</param>
      <returns>same collection instance</returns>
    </member>
    <member name="M:Lokad.ICollectionExtensions.IsEmpty``1(System.Collections.Generic.ICollection{``0})">
      <summary>
            Shortcut to determine whether the specified <see cref="T:System.Collections.Generic.ICollection`1" /> is empty.
            </summary>
      <typeparam name="T">items in the collection</typeparam>
      <param name="self">The collection.</param>
      <returns>
        <c>true</c> if the specified self is empty; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Lokad.ICommand">
      <summary>
            Generic interface for the command pattern.
            </summary>
    </member>
    <member name="M:Lokad.ICommand.Execute">
      <summary>
            Encapsulates action
            </summary>
    </member>
    <member name="T:System.Linq.IEnumerableExtensions">
      <summary>
            Helper methods for the <see cref="T:System.Collections.Generic.IEnumerable`1" /></summary>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            Performs the specified <see cref="T:System.Action`1" /> against every element of <see cref="T:System.Collections.Generic.IEnumerable`1" /></summary>
      <typeparam name="T">
      </typeparam>
      <param name="enumerable">Enumerable to extend</param>
      <param name="action">Action to perform</param>
      <exception cref="T:System.ArgumentNullException">When any parameter is null</exception>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
      <summary>
            Performs the specified <see cref="T:System.Action`1" /> against every element of <see cref="T:System.Collections.Generic.IEnumerable`1" /></summary>
      <typeparam name="T">
      </typeparam>
      <param name="enumerable">Enumerable to extend</param>
      <param name="action">Action to perform; second parameter represents the index</param>
      <exception cref="T:System.ArgumentNullException">When any parameter is null</exception>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.Apply``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            Applies the specified action to the target <paramref name="enumerable" />.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="enumerable">The enumerable.</param>
      <param name="action">The action to execute against every item.</param>
      <returns>enumerator</returns>
      <exception cref="T:System.ArgumentNullException">when one of the values is null</exception>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.Apply``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
      <summary>
            Applies the specified action to the target <paramref name="enumerable" />.
            </summary>
      <typeparam name="TSource">Type of the elements in <paramref name="enumerable" /></typeparam>
      <param name="enumerable">The enumerable.</param>
      <param name="action">The action to execute against every item; second
            parameter represents the index.</param>
      <returns>enumerator</returns>
      <exception cref="T:System.ArgumentNullException">when one of the values is null</exception>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
      <summary>
            Returns <em>True</em> as soon as the first member of <paramref name="enumerable" />
            mathes <paramref name="predicate" /></summary>
      <typeparam name="TSource">Type of the elements in <paramref name="enumerable" /></typeparam>
      <param name="enumerable">The enumerable</param>
      <param name="predicate">The predicate.</param>
      <returns>true if the <paramref name="enumerable" /> contains any elements
            matching <paramref name="predicate" /></returns>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.Exists``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Checks if the provided enumerable has anything
            </summary>
      <typeparam name="TSource">Type of the elements in <paramref name="enumerable" /></typeparam>
      <param name="enumerable">The enumerable.</param>
      <returns>true if the sequence contains any elements</returns>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.Append``1(System.Collections.Generic.IEnumerable{``0},``0[])">
      <summary>
            Appends the <paramref name="items" /> to the <paramref name="enumerable" />.
            </summary>
      <typeparam name="TSource">type of the elements in <paramref name="enumerable" /></typeparam>
      <param name="enumerable">The enumerable.</param>
      <param name="items">The item.</param>
      <returns>new sequence</returns>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.Append``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Appends the specified <paramref name="range" /> to the <paramref name="enumerable" />.
            </summary>
      <typeparam name="T">type of the item to operate with</typeparam>
      <param name="enumerable">The enumerable.</param>
      <param name="range">The range.</param>
      <returns>new enumerator instance</returns>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0[])">
      <summary>
            Prepends the specified <paramref name="enumerable" /> with the <paramref name="items" />.
            </summary>
      <typeparam name="T">type of the item to operate with</typeparam>
      <param name="enumerable">The enumerable.</param>
      <param name="items">The item.</param>
      <returns>new enumerator instance</returns>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.ToSet``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Converts the enumerable to <see cref="T:System.Collections.Generic.HashSet`1" /></summary>
      <typeparam name="T">
      </typeparam>
      <param name="enumerable">The enumerable.</param>
      <returns>hashset instance</returns>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.ToSet``2(System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0})">
      <summary>
            Converts the enumerable to <see cref="T:System.Collections.Generic.HashSet`1" /></summary>
      <typeparam name="TKey">The type of the key.</typeparam>
      <typeparam name="TItem">The type of the item.</typeparam>
      <param name="enumerable">The enumerable.</param>
      <param name="selector">The selector.</param>
      <returns>hashset instance</returns>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.Min``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Returns the minimum value in a generic sequence, using the provided comparer
            </summary>
      <typeparam name="T">Type of the elements of <paramref name="source" /></typeparam>
      <param name="source">Original sequence.</param>
      <param name="comparer">The comparer.</param>
      <returns>Maximum value</returns>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.Max``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Returns the maximum value in a generic sequence using the provided comparer.
            </summary>
      <typeparam name="T">Type of the elements of <paramref name="source" /></typeparam>
      <param name="source">Original sequence.</param>
      <param name="comparer">The comparer.</param>
      <returns>Maximum value</returns>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.Join(System.Collections.Generic.IEnumerable{System.String},System.String)">
      <summary>
            Concatenates a specified separator between each element of a specified <paramref name="strings" />, 
            yielding a single concatenated string.
            </summary>
      <param name="strings">The strings.</param>
      <param name="separator">The separator.</param>
      <returns>concatenated string</returns>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.Slice``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{``0,System.Int32},System.Int32)">
      <summary>
        <para>Performs lazy splitting of the provided collection into collections of <paramref name="sliceLength" />.</para>
        <para>Each collection will have total <em>weight</em> equal or less than <paramref name="maxSliceWeight" /></para>
      </summary>
      <typeparam name="TItem">The type of the item.</typeparam>
      <param name="source">The source collection to slice.</param>
      <param name="sliceLength">Length of the slice.</param>
      <param name="weightDelegate">Function to calculate <em>weight</em> of each item in the collection</param>
      <param name="maxSliceWeight">The max item weight.</param>
      <returns>enumerator over the results</returns>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.Slice``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>
            Performs lazy splitting of the provided collection into collections of <paramref name="sliceLength" /></summary>
      <typeparam name="TItem">The type of the item.</typeparam>
      <param name="source">The source.</param>
      <param name="sliceLength">Maximum length of the slice.</param>
      <returns>lazy enumerator of the collection of arrays</returns>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.ToJaggedArray``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
      <summary>
            Converts collection of collections to jagged array
            </summary>
      <typeparam name="T">type of the items in collection</typeparam>
      <param name="collection">The collection.</param>
      <returns>jagged array</returns>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.ToArray``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>
            Shorthand extension method for converting enumerables into the arrays
            </summary>
      <typeparam name="TSource">The type of the source array.</typeparam>
      <typeparam name="TTarget">The type of the target array.</typeparam>
      <param name="self">The collection to convert.</param>
      <param name="converter">The converter.</param>
      <returns>target array instance</returns>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.ToArray``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})">
      <summary>
            Shorthand extension method for converting enumerables into the arrays
            </summary>
      <typeparam name="TSource">The type of the source array.</typeparam>
      <typeparam name="TTarget">The type of the target array.</typeparam>
      <param name="self">The collection to convert.</param>
      <param name="converter">The converter, where the second parameter is an index of item being converted.</param>
      <returns>target array instance</returns>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.Distinct``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>
            returns distinct values from a sequence by using projecting each item to a new
            sequence with <paramref name="projection" /> and then selecting
            distinct values from it.
            </summary>
      <typeparam name="TItem">The type of the item.</typeparam>
      <typeparam name="TProjected">The type of the projected item.</typeparam>
      <param name="enumerable">The sequence to work with.</param>
      <param name="projection">The projection function.</param>
      <returns>sequence of distinct values</returns>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.FirstOrEmpty``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>
            Retrieves first value from the <paramref name="sequence" /></summary>
      <typeparam name="TSource">The type of the source sequence.</typeparam>
      <param name="sequence">The source.</param>
      <param name="predicate">The predicate.</param>
      <returns>first value</returns>
    </member>
    <member name="M:System.Linq.IEnumerableExtensions.ToIndexed``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Applies the integral indexer to the sequence
            </summary>
      <typeparam name="TSource">The type of the source.</typeparam>
      <param name="source">The sequence.</param>
      <returns>indexed sequence</returns>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="source" /> is null</exception>
    </member>
    <member name="T:Lokad.Diagnostics.ExecutionCounter">
      <summary>
        <para>
            Class to provide simple measurement of some method calls. 
            This class has been designed to provide light performance monitoring
            that could be used for instrumenting methods in production. It does 
            not use any locks and uses design to avoid 90% of concurrency issues.
            </para>
        <para>
            Counters are designed to be "cheap" and throwaway, so we basically we
            don't care about the remaining 10%
            </para>
        <para>
            The usage idea is simple - data is captured from the counters at
            regular intervals of time (i.e. 5-10 minutes). Counters are reset 
            after that. Data itself is aggregated on the monitoring side. 
            If there are some bad values (i.e. due to some rare race condition
            between multiple threads and monitoring scan) then the counter data
            is simply discarded.
            </para>
      </summary>
    </member>
    <member name="M:Lokad.Diagnostics.ExecutionCounter.#ctor(System.String,System.Int32,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Diagnostics.ExecutionCounter" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="openCounterCount">The open counter count.</param>
      <param name="closeCounterCount">The close counter count.</param>
    </member>
    <member name="M:Lokad.Diagnostics.ExecutionCounter.Open(System.Int64[])">
      <summary>
            Open the specified counter and adds the provided values to the openCounters collection
            </summary>
      <param name="openCounters">The open counters.</param>
      <returns>timestamp for the operation</returns>
    </member>
    <member name="M:Lokad.Diagnostics.ExecutionCounter.Close(System.Int64,System.Int64[])">
      <summary>
            Closes the specified timestamp.
            </summary>
      <param name="timestamp">The timestamp.</param>
      <param name="closeCounters">The close counters.</param>
    </member>
    <member name="M:Lokad.Diagnostics.ExecutionCounter.Reset">
      <summary>
            Resets this instance.
            </summary>
    </member>
    <member name="M:Lokad.Diagnostics.ExecutionCounter.ToStatistics">
      <summary>
            Converts this instance to <see cref="T:Lokad.Diagnostics.ExecutionStatistics" /></summary>
      <returns>
      </returns>
    </member>
    <member name="T:Lokad.Diagnostics.ExecutionStatistics">
      <summary>
            Statistics about some exection counter
            </summary>
    </member>
    <member name="M:Lokad.Diagnostics.ExecutionStatistics.#ctor(System.String,System.Int64,System.Int64,System.Int64[],System.Int64)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Diagnostics.ExecutionStatistics" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="openCount">The open count.</param>
      <param name="closeCount">The close count.</param>
      <param name="counters">The counters.</param>
      <param name="runningTime">The running time.</param>
    </member>
    <member name="P:Lokad.Diagnostics.ExecutionStatistics.OpenCount">
      <summary>
            Gets the number of times the counter has been opened
            </summary>
      <value>The open count.</value>
    </member>
    <member name="P:Lokad.Diagnostics.ExecutionStatistics.CloseCount">
      <summary>
            Gets the number of times the counter has been properly closed.
            </summary>
      <value>The close count.</value>
    </member>
    <member name="P:Lokad.Diagnostics.ExecutionStatistics.Counters">
      <summary>
            Gets the native counters collected by this counter.
            </summary>
      <value>The counters.</value>
    </member>
    <member name="P:Lokad.Diagnostics.ExecutionStatistics.RunningTime">
      <summary>
            Gets the total running time between open and close statements in ticks.
            </summary>
      <value>The running time expressed in 100-nanosecond units.</value>
    </member>
    <member name="P:Lokad.Diagnostics.ExecutionStatistics.Name">
      <summary>
            Gets the name for this counter.
            </summary>
      <value>The name.</value>
    </member>
    <member name="T:Lokad.Container.RegistrationType">
      <summary>
            Enum that defines registration modes for the auto-registration
            </summary>
    </member>
    <member name="F:Lokad.Container.RegistrationType.Type">
      <summary>
            Component is to be registered by its type
            </summary>
    </member>
    <member name="F:Lokad.Container.RegistrationType.Name">
      <summary>
            Component is to be registered by its name
            </summary>
    </member>
    <member name="F:Lokad.Container.RegistrationType.Service">
      <summary>
            Component is to be registered as a service
            </summary>
    </member>
    <member name="T:Lokad.StreamExtensions">
      <summary>
            Simple helper extensions for the <see cref="T:System.IO.Stream" /></summary>
    </member>
    <member name="M:Lokad.StreamExtensions.Compress(System.IO.Stream)">
      <summary>
            Wraps the specified stream with Compression stream
            </summary>
      <param name="stream">The stream to compress</param>
      <returns>compressing stream</returns>
    </member>
    <member name="M:Lokad.StreamExtensions.Compress(System.IO.Stream,System.Boolean)">
      <summary>
            Wraps the specified stream with Compression stream
            </summary>
      <param name="stream">The stream the stream to compress.</param>
      <param name="leaveOpen">
        <c>true</c> to leave the stream open; overwise <c>false</c>.</param>
      <returns>compressing stream</returns>
    </member>
    <member name="M:Lokad.StreamExtensions.Decompress(System.IO.Stream)">
      <summary>
            Wraps the stream with Decompressing stream
            </summary>
      <param name="stream">The stream to decompress.</param>
      <returns>decompressing stream</returns>
    </member>
    <member name="M:Lokad.StreamExtensions.Decompress(System.IO.Stream,System.Boolean)">
      <summary>
            Wraps the stream with Decompressing stream
            </summary>
      <param name="stream">The stream to decompress.</param>
      <param name="leaveOpen">
        <c>true</c> to leave the stream open; overwise <c>false</c>.</param>
      <returns>decompressing stream</returns>
    </member>
    <member name="M:Lokad.StreamExtensions.PumpTo(System.IO.Stream,System.IO.Stream,System.Int32)">
      <summary>
            Copies contents of this stream to the target stream
            </summary>
      <param name="source">The source.</param>
      <param name="target">The target.</param>
      <param name="bufferSize">Size of the buffer.</param>
      <returns>total amount of bytes copied</returns>
    </member>
    <member name="M:Lokad.StreamExtensions.PumpTo(System.IO.Stream,System.IO.Stream,System.Byte[])">
      <summary>
            Copies contents of this stream to the target stream, using the provided buffer
            </summary>
      <param name="source">The source.</param>
      <param name="target">The target.</param>
      <param name="buffer">The buffer.</param>
      <returns>total amount of bytes copied</returns>
    </member>
    <member name="T:Lokad.SystemUtil">
      <summary>
            System utils to improve testability of the code
            </summary>
    </member>
    <member name="F:Lokad.SystemUtil.SleepAction">
      <summary>
        <see cref="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      </summary>
    </member>
    <member name="F:Lokad.SystemUtil.DateTimeProvider">
      <summary>
            Allows to set custom date time implementation for the testing purposes.
            </summary>
    </member>
    <member name="M:Lokad.SystemUtil.Reset">
      <summary>
            Returns all overridable functions to default. To be used by test teardowns
            </summary>
    </member>
    <member name="M:Lokad.SystemUtil.SetSleep(System.Action{System.TimeSpan})">
      <summary>
            Sets the custom sleep routine.
            </summary>
      <param name="sleepRoutine">The sleep routine.</param>
    </member>
    <member name="M:Lokad.SystemUtil.SetDateTimeProvider(System.Func{System.DateTime})">
      <summary>
            Sets the custom date time provider routine.
            </summary>
      <param name="dateTimeProvider">The date time provider.</param>
    </member>
    <member name="M:Lokad.SystemUtil.SetTime(System.DateTime)">
      <summary>
            Shortcut to set the custom date time.
            </summary>
      <param name="time">The time.</param>
    </member>
    <member name="M:Lokad.SystemUtil.Sleep(System.TimeSpan)">
      <summary>
            Invokes the method associated with sleeping. For the production purposes
            this should be a call to <see cref="M:System.Threading.Thread.Sleep(System.TimeSpan)" /></summary>
      <param name="span">The span.</param>
    </member>
    <member name="P:Lokad.SystemUtil.Now">
      <summary>
        <see cref="P:System.DateTime.Now" />
      </summary>
    </member>
    <member name="T:Lokad.VersionUtil">
      <summary>
            Helper class for <see cref="T:System.Version" /></summary>
    </member>
    <member name="M:Lokad.VersionUtil.Normalize(System.Version)">
      <summary>
            Normalizes the specified version by replacing all -1 with 0
            </summary>
      <param name="version">The version.</param>
      <returns>version that has all 0 replaced with -1</returns>
    </member>
    <member name="T:Lokad.XmlUtil`1">
      <summary>
            Simple static class that caches <see cref="T:System.Xml.Serialization.XmlSerializer" /> instances.
            </summary>
      <typeparam name="TXml">
      </typeparam>
    </member>
    <member name="M:Lokad.XmlUtil`1.Serialize(`0,System.IO.TextWriter)">
      <summary> Serializes instance to the provided writer </summary>
    </member>
    <member name="M:Lokad.XmlUtil`1.Serialize(`0,System.IO.Stream)">
      <summary> Serializes instance to the provided stream </summary>
    </member>
    <member name="M:Lokad.XmlUtil`1.Serialize(`0)">
      <summary>
            Serializes instance to the Xml string
            </summary>
      <param name="instance">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Lokad.XmlUtil`1.Deserialize(System.String)">
      <summary>
            Helper method for testing - quickly creates object from string
            </summary>
      <param name="source">xml string</param>
      <returns>
      </returns>
    </member>
    <member name="M:Lokad.XmlUtil`1.Deserialize(System.IO.Stream)">
      <summary>
            Helper method to deserialize from the stream using
            the cached serializer.
            </summary>
      <param name="stream">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Lokad.XmlUtil">
      <summary>
            Helper class for the xml operations
            </summary>
    </member>
    <member name="M:Lokad.XmlUtil.TestXmlSerialization``1(``0)">
      <summary>
            Helper method for testing - checks if the object can be serialized
            </summary>
      <typeparam name="TData">The type of the data.</typeparam>
      <param name="item">The item.</param>
      <returns>deserialized item</returns>
    </member>
    <member name="M:Lokad.XmlUtil.TestXmlSerialization``1">
      <summary>
            Helper method for testing - checks if the class can be serialized
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Lokad.XmlUtil.TestXmlSerialization(System.Type)">
      <summary>
            Tests the XML serialization.
            </summary>
      <param name="type">The type.</param>
    </member>
    <member name="M:Lokad.XmlUtil.Serialize``1(``0,System.IO.TextWriter)">
      <summary>
        <see cref="M:Lokad.XmlUtil`1.Serialize(`0,System.IO.Stream)" />
      </summary>
      <typeparam name="T">
      </typeparam>
      <param name="stream">
      </param>
      <param name="instance">
      </param>
    </member>
    <member name="M:Lokad.XmlUtil.SerializeArray``1(``0[],System.IO.TextWriter)">
      <summary>
        <see cref="M:Lokad.XmlUtil`1.Serialize(`0,System.IO.Stream)" />
      </summary>
      <typeparam name="T">type of the item to serialize</typeparam>
      <param name="stream">The stream.</param>
      <param name="array">The array.</param>
    </member>
    <member name="M:Lokad.XmlUtil.Serialize``1(``0,System.IO.Stream)">
      <summary>
        <see cref="M:Lokad.XmlUtil`1.Serialize(`0,System.IO.Stream)" />
      </summary>
      <typeparam name="T">
      </typeparam>
      <param name="stream">
      </param>
      <param name="instance">
      </param>
    </member>
    <member name="M:Lokad.XmlUtil.SerializeArray``1(``0[],System.IO.Stream)">
      <summary>
        <see cref="M:Lokad.XmlUtil`1.Serialize(`0,System.IO.Stream)" />
      </summary>
      <typeparam name="T">type of the item to serialize</typeparam>
      <param name="stream">The stream.</param>
      <param name="array">The array.</param>
    </member>
    <member name="M:Lokad.XmlUtil.Deserialize``1(System.IO.Stream)">
      <summary>
        <see cref="M:Lokad.XmlUtil`1.Deserialize(System.IO.Stream)" />
      </summary>
      <typeparam name="T">
      </typeparam>
      <param name="stream">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Lokad.XmlUtil.Serialize``1(``0)">
      <summary> Serializes the specified instance. </summary>
      <typeparam name="T">type of the item to serialize</typeparam>
      <param name="instance">The instance.</param>
      <returns>String representation</returns>
    </member>
    <member name="M:Lokad.XmlUtil.SerializeTo``1(``0,System.String)">
      <summary>
            Serializes the specified instance to the specified file
            </summary>
      <typeparam name="TXml">The type of the XML-serializable object.</typeparam>
      <param name="instance">The instance.</param>
      <param name="fileName">Name of the file.</param>
    </member>
    <member name="M:Lokad.XmlUtil.SerializeArray``1(``0[])">
      <summary>
            Serializes the specified instance.
            </summary>
      <typeparam name="T">type of the item to serialize</typeparam>
      <param name="array">The array.</param>
      <returns>String representation</returns>
    </member>
    <member name="T:GlobalAssemblyInfo">
      <summary>
             Assembly information class that is shared between all projects
            </summary>
    </member>
    <member name="T:Lokad.ILog">
      <summary>
            Shared interface to abstract away from the specific
            logging library
            </summary>
    </member>
    <member name="M:Lokad.ILog.Log(Lokad.LogLevel,System.Object)">
      <summary> Writes the message to the logger </summary>
      <param name="level">The importance level</param>
      <param name="message">The actual message</param>
    </member>
    <member name="M:Lokad.ILog.Log(Lokad.LogLevel,System.Exception,System.Object)">
      <summary>
            Writes the exception and associated information 
            to the logger
            </summary>
      <param name="level">The importance level</param>
      <param name="ex">The actual exception</param>
      <param name="message">Information related to the exception</param>
    </member>
    <member name="M:Lokad.ILog.IsEnabled(Lokad.LogLevel)">
      <summary>
            Determines whether the messages of specified level are being logged down
            </summary>
      <param name="level">The level.</param>
      <returns>
        <c>true</c> if the specified level is logged; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Lokad.Diagnostics.DebugLog">
      <summary>
        <see cref="T:Lokad.ILog" /> that writes to the <see cref="P:System.Diagnostics.Debug.Listeners" /></summary>
    </member>
    <member name="F:Lokad.Diagnostics.DebugLog.Instance">
      <summary>
            Singleton instance of the <see cref="T:Lokad.Diagnostics.DebugLog" /></summary>
    </member>
    <member name="F:Lokad.Diagnostics.DebugLog.Provider">
      <summary>
            Named provider for the <see cref="T:Lokad.Diagnostics.DebugLog" /></summary>
    </member>
    <member name="T:Lokad.Diagnostics.ExceptionLogDecorator">
      <summary>
            Simple decorator for <see cref="T:Lokad.ILog" /> that saves 
            all incoming exceptions to the <see cref="T:Lokad.Diagnostics.ExceptionCounters" /></summary>
    </member>
    <member name="M:Lokad.Diagnostics.ExceptionLogDecorator.#ctor(Lokad.ILog,Lokad.Diagnostics.ExceptionCounters)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Diagnostics.ExceptionLogDecorator" /> class.
            </summary>
      <param name="log">The log.</param>
      <param name="counter">The counter.</param>
    </member>
    <member name="T:Lokad.Diagnostics.NullLog">
      <summary>
        <see cref="T:Lokad.ILog" /> that does not do anything
            </summary>
    </member>
    <member name="F:Lokad.Diagnostics.NullLog.Instance">
      <summary>
            Singleton instance of the <see cref="T:Lokad.ILog" /></summary>
    </member>
    <member name="F:Lokad.Diagnostics.NullLog.Provider">
      <summary>
            Named provider for the <see cref="T:Lokad.Diagnostics.NullLog" /></summary>
    </member>
    <member name="T:Lokad.Diagnostics.TraceLog">
      <summary>
        <see cref="T:Lokad.ILog" /> that writes to the <see cref="P:System.Diagnostics.Trace.Listeners" /></summary>
    </member>
    <member name="F:Lokad.Diagnostics.TraceLog.Instance">
      <summary>  Singleton instance </summary>
    </member>
    <member name="F:Lokad.Diagnostics.TraceLog.Provider">
      <summary>
            Named provider for the <see cref="T:Lokad.Diagnostics.TraceLog" /></summary>
    </member>
    <member name="T:Lokad.ILogExtensions">
      <summary>
            Helper extensions for any class that implements <see cref="T:Lokad.ILog" /></summary>
    </member>
    <member name="M:Lokad.ILogExtensions.IsDebugEnabled(Lokad.ILog)">
      <summary>
            Determines whether the specified log is recording debug messages.
            </summary>
      <param name="log">The log.</param>
      <returns>
        <c>true</c> if the specified log is recording debug messages; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.ILogExtensions.Debug(Lokad.ILog,System.Object)">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Debug" /> level
            </summary>
      <param name="log">Log instance being extended</param>
      <param name="message">Message</param>
    </member>
    <member name="M:Lokad.ILogExtensions.DebugFormat(Lokad.ILog,System.String,System.Object[])">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Debug" /> level
            </summary>
      <param name="log">Log instance being extended</param>
      <param name="format">Format string as in 
            <see cref="M:System.String.Format(System.String,System.Object[])" /></param>
      <param name="args">Arguments</param>
    </member>
    <member name="M:Lokad.ILogExtensions.Debug(Lokad.ILog,System.Exception,System.Object)">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Debug" /> level and
            appends the specified <see cref="T:System.Exception" /></summary>
      <param name="log">Log instance being extended</param>
      <param name="ex">Exception to add to the message</param>
      <param name="message">Message</param>
    </member>
    <member name="M:Lokad.ILogExtensions.DebugFormat(Lokad.ILog,System.Exception,System.String,System.Object[])">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Debug" /> level and
            appends the specified <see cref="T:System.Exception" /></summary>
      <param name="log">Log instance being extended</param>
      <param name="ex">Exception to add to the message</param>
      <param name="format">Format string as in 
            <see cref="M:System.String.Format(System.String,System.Object[])" /></param>
      <param name="args">Arguments</param>
    </member>
    <member name="M:Lokad.ILogExtensions.IsInfoEnabled(Lokad.ILog)">
      <summary>
            Determines whether the specified log is recording info messages.
            </summary>
      <param name="log">The log.</param>
      <returns>
        <c>true</c> if the specified log is recording info messages; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.ILogExtensions.Info(Lokad.ILog,System.Object)">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Info" /> level
            </summary>
      <param name="log">Log instance being extended</param>
      <param name="message">Message</param>
    </member>
    <member name="M:Lokad.ILogExtensions.InfoFormat(Lokad.ILog,System.String,System.Object[])">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Info" /> level
            </summary>
      <param name="log">Log instance being extended</param>
      <param name="format">Format string as in 
            <see cref="M:System.String.Format(System.String,System.Object[])" /></param>
      <param name="args">Arguments</param>
    </member>
    <member name="M:Lokad.ILogExtensions.Info(Lokad.ILog,System.Exception,System.Object)">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Info" /> level and
            appends the specified <see cref="T:System.Exception" /></summary>
      <param name="log">Log instance being extended</param>
      <param name="ex">Exception to add to the message</param>
      <param name="message">Message</param>
    </member>
    <member name="M:Lokad.ILogExtensions.InfoFormat(Lokad.ILog,System.Exception,System.String,System.Object[])">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Info" /> level and
            appends the specified <see cref="T:System.Exception" /></summary>
      <param name="log">Log instance being extended</param>
      <param name="ex">Exception to add to the message</param>
      <param name="format">Format string as in 
            <see cref="M:System.String.Format(System.String,System.Object[])" /></param>
      <param name="args">Arguments</param>
    </member>
    <member name="M:Lokad.ILogExtensions.IsWarnEnabled(Lokad.ILog)">
      <summary>
            Determines whether the specified log is recording warning messages.
            </summary>
      <param name="log">The log.</param>
      <returns>
        <c>true</c> if the specified log is recording warning messages; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.ILogExtensions.Warn(Lokad.ILog,System.Object)">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Warn" /> level
            </summary>
      <param name="log">Log instance being extended</param>
      <param name="message">Message</param>
    </member>
    <member name="M:Lokad.ILogExtensions.WarnFormat(Lokad.ILog,System.String,System.Object[])">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Warn" /> level
            </summary>
      <param name="log">Log instance being extended</param>
      <param name="format">Format string as in 
            <see cref="M:System.String.Format(System.String,System.Object[])" /></param>
      <param name="args">Arguments</param>
    </member>
    <member name="M:Lokad.ILogExtensions.Warn(Lokad.ILog,System.Exception,System.Object)">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Warn" /> level and
            appends the specified <see cref="T:System.Exception" /></summary>
      <param name="log">Log instance being extended</param>
      <param name="ex">Exception to add to the message</param>
      <param name="message">Message</param>
    </member>
    <member name="M:Lokad.ILogExtensions.WarnFormat(Lokad.ILog,System.Exception,System.String,System.Object[])">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Warn" /> level and
            appends the specified <see cref="T:System.Exception" /></summary>
      <param name="log">Log instance being extended</param>
      <param name="ex">Exception to add to the message</param>
      <param name="format">Format string as in 
            <see cref="M:System.String.Format(System.String,System.Object[])" /></param>
      <param name="args">Arguments</param>
    </member>
    <member name="M:Lokad.ILogExtensions.IsErrorEnabled(Lokad.ILog)">
      <summary>
            Determines whether the specified log is recording error messages.
            </summary>
      <param name="log">The log.</param>
      <returns>
        <c>true</c> if the specified log is recording error messages; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.ILogExtensions.Error(Lokad.ILog,System.Object)">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Error" /> level
            </summary>
      <param name="log">Log instance being extended</param>
      <param name="message">Message</param>
    </member>
    <member name="M:Lokad.ILogExtensions.ErrorFormat(Lokad.ILog,System.String,System.Object[])">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Error" /> level
            </summary>
      <param name="log">Log instance being extended</param>
      <param name="format">Format string as in 
            <see cref="M:System.String.Format(System.String,System.Object[])" /></param>
      <param name="args">Arguments</param>
    </member>
    <member name="M:Lokad.ILogExtensions.Error(Lokad.ILog,System.Exception,System.Object)">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Error" /> level and
            appends the specified <see cref="T:System.Exception" /></summary>
      <param name="log">Log instance being extended</param>
      <param name="ex">Exception to add to the message</param>
      <param name="message">Message</param>
    </member>
    <member name="M:Lokad.ILogExtensions.ErrorFormat(Lokad.ILog,System.Exception,System.String,System.Object[])">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Error" /> level and
            appends the specified <see cref="T:System.Exception" /></summary>
      <param name="log">Log instance being extended</param>
      <param name="ex">Exception to add to the message</param>
      <param name="format">Format string as in 
            <see cref="M:System.String.Format(System.String,System.Object[])" /></param>
      <param name="args">Arguments</param>
    </member>
    <member name="M:Lokad.ILogExtensions.IsFatalEnabled(Lokad.ILog)">
      <summary>
            Determines whether the specified log is recording Fatal messages.
            </summary>
      <param name="log">The log.</param>
      <returns>
        <c>true</c> if the specified log is recording datal messages; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.ILogExtensions.Fatal(Lokad.ILog,System.Object)">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Fatal" /> level
            </summary>
      <param name="log">Log instance being extended</param>
      <param name="message">Message</param>
    </member>
    <member name="M:Lokad.ILogExtensions.FatalFormat(Lokad.ILog,System.String,System.Object[])">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Fatal" /> level
            </summary>
      <param name="log">Log instance being extended</param>
      <param name="format">Format string as in 
            <see cref="M:System.String.Format(System.String,System.Object[])" /></param>
      <param name="args">Arguments</param>
    </member>
    <member name="M:Lokad.ILogExtensions.Fatal(Lokad.ILog,System.Exception,System.Object)">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Fatal" /> level and
            appends the specified <see cref="T:System.Exception" /></summary>
      <param name="log">Log instance being extended</param>
      <param name="ex">Exception to add to the message</param>
      <param name="message">Message</param>
    </member>
    <member name="M:Lokad.ILogExtensions.FatalFormat(Lokad.ILog,System.Exception,System.String,System.Object[])">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Fatal" /> level and
            appends the specified <see cref="T:System.Exception" /></summary>
      <param name="log">Log instance being extended</param>
      <param name="ex">Exception to add to the message</param>
      <param name="format">Format string as in 
            <see cref="M:System.String.Format(System.String,System.Object[])" /></param>
      <param name="args">Arguments</param>
    </member>
    <member name="T:Lokad.ILogProvider">
      <summary>
            Creates logs using the name
            </summary>
    </member>
    <member name="T:Lokad.ILogProviderExtensions">
      <summary>
            Extension methods for the <see cref="T:Lokad.INamedProvider`1" />
            of <see cref="T:Lokad.ILog" /></summary>
    </member>
    <member name="M:Lokad.ILogProviderExtensions.CreateLog``1(Lokad.INamedProvider{Lokad.ILog})">
      <summary>
            Creates new log using the type as name.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Lokad.LogLevel">
      <summary>
            Degines the importance level associated with the log
            entry in <see cref="T:Lokad.ILog" /></summary>
    </member>
    <member name="F:Lokad.LogLevel.Debug">
      <summary> Message is intended for debugging </summary>
    </member>
    <member name="F:Lokad.LogLevel.Info">
      <summary> Informatory message </summary>
    </member>
    <member name="F:Lokad.LogLevel.Warn">
      <summary> The message is about potential problem in the system </summary>
    </member>
    <member name="F:Lokad.LogLevel.Error">
      <summary> Some error has occured </summary>
    </member>
    <member name="F:Lokad.LogLevel.Fatal">
      <summary> Message is associated with the critical problem </summary>
    </member>
    <member name="F:Lokad.LogLevel.Max">
      <summary>
            Highest possible level
            </summary>
    </member>
    <member name="F:Lokad.LogLevel.Min">
      <summary> Smallest logging level</summary>
    </member>
    <member name="T:GlobalAssemblyInfo">
      <summary>
             Assembly information class that is shared between all projects
            </summary>
    </member>
    <member name="T:Lokad.ActionPolicy">
      <summary>
            Policy that could be applied to delegates to
            augment their behavior (i.e. to retry on problems)
            </summary>
    </member>
    <member name="F:Lokad.ActionPolicy.Null">
      <summary>
            Action policy that does not do anything
            </summary>
    </member>
    <member name="M:Lokad.ActionPolicy.#ctor(System.Action{System.Action})">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.ActionPolicy" /> class.
            </summary>
      <param name="policy">The policy.</param>
    </member>
    <member name="M:Lokad.ActionPolicy.Do(System.Action)">
      <summary>
            Performs the specified action within the policy.
            </summary>
      <param name="action">The action to perform.</param>
    </member>
    <member name="M:Lokad.ActionPolicy.Get``1(System.Func{``0})">
      <summary>
            Performs the specified action within the policy and returns the result
            </summary>
      <typeparam name="TResult">The type of the result.</typeparam>
      <param name="action">The action to perform.</param>
      <returns>result returned by <paramref name="action" /></returns>
    </member>
    <member name="M:Lokad.ActionPolicy.With(Lokad.ExceptionHandler)">
      <summary> Starts building <see cref="T:Lokad.ActionPolicy" /> 
            that can handle exceptions, as determined by 
            <paramref name="handler" /></summary>
      <param name="handler">The exception handler.</param>
      <returns>syntax</returns>
    </member>
    <member name="M:Lokad.ActionPolicy.Handle``1">
      <summary> Starts building simple <see cref="T:Lokad.ActionPolicy" />
            that can handle <typeparamref name="TException" /></summary>
      <typeparam name="TException">The type of the exception to handle.</typeparam>
      <returns>syntax</returns>
    </member>
    <member name="M:Lokad.ActionPolicy.Handle``2">
      <summary> Starts building simple <see cref="T:Lokad.ActionPolicy" />
            that can handle <typeparamref name="TEx1" /> or <typeparamref name="TEx1" /></summary>
      <typeparam name="TEx1">The type of the exception to handle.</typeparam>
      <typeparam name="TEx2">The type of the exception to handle.</typeparam>
      <returns>syntax</returns>
    </member>
    <member name="M:Lokad.ActionPolicy.Handle``3">
      <summary> Starts building simple <see cref="T:Lokad.ActionPolicy" />
            that can handle <typeparamref name="TEx1" /> or <typeparamref name="TEx1" /></summary>
      <typeparam name="TEx1">The first type of the exception to handle.</typeparam>
      <typeparam name="TEx2">The second of the exception to handle.</typeparam>
      <typeparam name="TEx3">The third of the exception to handle.</typeparam>
      <returns>syntax</returns>
    </member>
    <member name="T:Lokad.ActionPolicyWithState">
      <summary>
            Same as <see cref="T:Lokad.ActionPolicy" />, but indicates that this policy
            holds some state and thus must have syncronized access.
            </summary>
    </member>
    <member name="M:Lokad.ActionPolicyWithState.#ctor(System.Action{System.Action})">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.ActionPolicyWithState" /> class.
            </summary>
      <param name="policy">The policy.</param>
    </member>
    <member name="T:Lokad.ExceptionHandler">
      <summary> This delegate represents <em>catch</em> block
            </summary>
      <param name="ex">Exception to handle</param>
      <returns>
        <em>true</em> if we can handle exception</returns>
    </member>
    <member name="T:Lokad.ExceptionHandlerSyntax">
      <summary> Fluent API for defining <see cref="T:Lokad.ActionPolicy" /> 
            that allows to handle exceptions. </summary>
    </member>
    <member name="M:Lokad.ExceptionHandlerSyntax.Retry(Lokad.Syntax{Lokad.ExceptionHandler},System.Int32)">
      <summary>
            Builds <see cref="T:Lokad.ActionPolicy" /> that will retry exception handling
            for a couple of times before giving up.
            </summary>
      <param name="syntax">The syntax.</param>
      <param name="retryCount">The retry count.</param>
      <returns>reusable instance of policy</returns>
    </member>
    <member name="M:Lokad.ExceptionHandlerSyntax.Retry(Lokad.Syntax{Lokad.ExceptionHandler},System.Int32,System.Action{System.Exception,System.Int32})">
      <summary>
            Builds <see cref="T:Lokad.ActionPolicy" /> that will retry exception handling
            for a couple of times before giving up.
            </summary>
      <param name="syntax">The syntax.</param>
      <param name="retryCount">The retry count.</param>
      <param name="onRetry">The action to perform on retry (i.e.: write to log).
            First parameter is the exception and second one is its number in sequence. </param>
      <returns>reusable policy instance </returns>
    </member>
    <member name="M:Lokad.ExceptionHandlerSyntax.RetryForever(Lokad.Syntax{Lokad.ExceptionHandler},System.Action{System.Exception})">
      <summary> Builds <see cref="T:Lokad.ActionPolicy" /> that will keep retrying forever </summary>
      <param name="syntax">The syntax to extend.</param>
      <param name="onRetry">The action to perform when the exception could be retried.</param>
      <returns> reusable instance of policy</returns>
    </member>
    <member name="M:Lokad.ExceptionHandlerSyntax.WaitAndRetry(Lokad.Syntax{Lokad.ExceptionHandler},System.Collections.Generic.IEnumerable{System.TimeSpan},System.Action{System.Exception,System.TimeSpan})">
      <summary>
        <para>Builds the policy that will keep retrying as long as 
            the exception could be handled by the <paramref name="syntax" /> being 
            built and <paramref name="sleepDurations" /> is providing the sleep intervals.
            </para>
        <para>See <see cref="T:Lokad.Range" /> for methods to create long intervals on-the-fly</para>
      </summary>
      <param name="syntax">The syntax.</param>
      <param name="sleepDurations">The sleep durations.</param>
      <param name="onRetry">The action to perform on retry (i.e.: write to log).
            First parameter is the exception and second one is the planned sleep duration. </param>
      <returns>new policy instance</returns>
    </member>
    <member name="M:Lokad.ExceptionHandlerSyntax.WaitAndRetry(Lokad.Syntax{Lokad.ExceptionHandler},System.Collections.Generic.IEnumerable{System.TimeSpan})">
      <summary>
        <para>Builds the policy that will keep retrying as long as 
            the exception could be handled by the <paramref name="syntax" /> being 
            built and <paramref name="sleepDurations" /> is providing the sleep intervals.
            </para>
        <para>See <see cref="T:Lokad.Range" /> for methods to create long intervals on-the-fly</para>
      </summary>
      <param name="syntax">The syntax.</param>
      <param name="sleepDurations">The sleep durations.</param>
      <returns>new policy instance</returns>
    </member>
    <member name="M:Lokad.ExceptionHandlerSyntax.CircuitBreaker(Lokad.Syntax{Lokad.ExceptionHandler},System.TimeSpan,System.Int32)">
      <summary>
        <para>Builds the policy that will "break the circuit" after <paramref name="countBeforeBreaking" />
            exceptions that could be handled by the <paramref name="syntax" /> being built. The circuit 
            stays broken for the <paramref name="duration" />. Any attempt to
            invoke method within the policy, while the circuit is broken, will immediately re-throw
            the last exception.  </para>
        <para>If the action fails within the policy after the block period, then the breaker 
            is blocked again for the next <paramref name="duration" />.
            It will be reset, otherwise.</para>
      </summary>
      <param name="syntax">The syntax.</param>
      <param name="duration">How much time the breaker will stay open before resetting</param>
      <param name="countBeforeBreaking">How many exceptions are needed to break the circuit</param>
      <returns>shared policy instance</returns>
      <remarks>(see "ReleaseIT!" for the details)</remarks>
    </member>
    <member name="T:Lokad.HandlingProvider`2">
      <summary>
            Simple reliability layer for the <see cref="T:Lokad.IProvider`2" /></summary>
      <typeparam name="TKey">type of the Key item</typeparam>
      <typeparam name="TValue">type of the values</typeparam>
    </member>
    <member name="M:Lokad.HandlingProvider`2.#ctor(Lokad.IProvider{`0,`1},Lokad.ActionPolicy)">
      <summary>
            Creates generic reliability wrapper around the <see cref="T:Lokad.IProvider`2" /></summary>
      <param name="provider">
      </param>
      <param name="policy">
      </param>
    </member>
    <member name="M:Lokad.HandlingProvider`2.Get(`0)">
      <summary>
        <see cref="M:Lokad.IProvider`2.Get(`0)" />
      </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Lokad.HandlingProvider">
      <summary>
            This shortcuts simplifies creation of <see cref="T:Lokad.HandlingProvider" /> instances
            </summary>
    </member>
    <member name="M:Lokad.HandlingProvider.For``2(Lokad.IProvider{``0,``1},Lokad.ActionPolicy)">
      <summary>
            Creates new instance of <see cref="T:Lokad.HandlingProvider`2" />
            by wrapping another <see cref="T:Lokad.IProvider`2" /> instance
            </summary>
      <typeparam name="TKey">The type of the key.</typeparam>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="provider">The provider to wrap.</param>
      <param name="policy">The action policy.</param>
      <returns>new provider instance</returns>
    </member>
  </members>
</doc>